<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Julien Richard-Foy, Zengularity" />
  <title>Scala Course</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Scala Course</h1>
  <p class="author">
Julien Richard-Foy, Zengularity
  </p>
</div>
<div id="overview" class="titleslide slide section level1"><h1><span class="header-section-number">1</span> Overview</h1></div><div id="why-scala" class="slide section level2">
<h1><span class="header-section-number">1.1</span> Why Scala?</h1>
<blockquote>
<p>A problem <strong>well put</strong> is <strong>half solved</strong>.</p>
</blockquote>
<p>John Dewey</p>
<blockquote>
<p>A <strong>scalable</strong> programming language is one in which the <strong>same</strong> concepts can describe <strong>small</strong> as well as <strong>large</strong> parts.</p>
</blockquote>
<p>Martin Odersky</p>
</div><div id="scala-in-a-few-words" class="slide section level2">
<h1><span class="header-section-number">1.2</span> Scala in a Few Words</h1>
<p>Scala is a <strong>general purpose programming language</strong></p>
<p>Scala is <strong>object oriented</strong></p>
<p>Scala is <strong>statically typed</strong></p>
<p>Scala enables both <strong>functional programming</strong> and <strong>imperative programming</strong></p>
</div><div id="hello-world" class="slide section level2">
<h1><span class="header-section-number">1.3</span> Hello World</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Main <span class="kw">extends</span> App {
  <span class="fu">println</span>(<span class="st">&quot;Hello, World!&quot;</span>)
}</code></pre>
</div><div id="flexible-syntax" class="slide section level2">
<h1><span class="header-section-number">1.4</span> Flexible Syntax</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="st">&quot;The &#39;Hello world&#39; string&quot;</span> should {
  <span class="st">&quot;contain 11 characters&quot;</span> in {
    <span class="st">&quot;Hello world&quot;</span> must have <span class="fu">size</span> (<span class="dv">11</span>)
  }
}</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> PingPong <span class="kw">extends</span> Actor {
  <span class="kw">def</span> receive = {
    <span class="kw">case</span> x =&gt; sender ! x
  }
}</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> ExprParser <span class="kw">extends</span> RegexParsers {
  <span class="kw">def</span> factor = <span class="st">&quot;[0-9]+&quot;</span>.<span class="fu">r</span> | <span class="st">&quot;(&quot;</span>~expr~<span class="st">&quot;)&quot;</span>
  <span class="kw">def</span> term = factor~(<span class="st">&quot;*&quot;</span> | <span class="st">&quot;/&quot;</span>)~factor
  <span class="kw">def</span> expr = term~(<span class="st">&quot;+&quot;</span> | <span class="st">&quot;-&quot;</span>)~term
}</code></pre>
</div>
<div id="start-programming" class="titleslide slide section level1"><h1><span class="header-section-number">2</span> Start programming</h1></div><div id="read-eval-print-loop" class="slide section level2">
<h1><span class="header-section-number">2.1</span> Read-Eval-Print Loop</h1>
<p>The quickest way to try Scala is to use the REPL (Read-Eval-Print-Loop)</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">sbt</span> console
<span class="kw">Welcome</span> to Scala version 2.11.5 (Java HotSpot(TM) <span class="kw">64-Bit</span> Server VM, Java 1.8.0_40)<span class="kw">.</span>
<span class="kw">Type</span> in expressions to have them evaluated.
<span class="kw">Type</span> :help for more information.

<span class="kw">scala&gt;</span> </code></pre>
<p>(Check that <a href="http://www.scala-sbt.org">sbt</a> is installed on your system)</p>
</div>
<div id="values-and-types" class="titleslide slide section level1"><h1><span class="header-section-number">3</span> Values and Types</h1></div><div id="what-is-a-program-made-of" class="slide section level2">
<h1><span class="header-section-number">3.1</span> What is a program made of?</h1>
<ul>
<li><p>A program is the <strong>expression</strong> of the solution of a given <strong>problem</strong></p></li>
<li><p>We need a way to define and refer to the elements of the <strong>problem domain</strong></p></li>
</ul>
</div><div id="the-simplest-program-elements-literal-values" class="slide section level2">
<h1><span class="header-section-number">3.2</span> The Simplest Program Elements: Literal Values</h1>
<blockquote>
<p>What is “the answer to life the universe and everything”?</p>
</blockquote>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="dv">42</span>
res0: Int = <span class="dv">42</span></code></pre>
<blockquote>
<p>What is my name?</p>
</blockquote>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="st">&quot;Julien&quot;</span>
res1: String = Julien</code></pre>
<ul>
<li><code>42</code> and <code>&quot;Julien&quot;</code> are <strong>values</strong> composed of a single <strong>literal value</strong>.</li>
</ul>
</div><div id="compound-values-operators" class="slide section level2">
<h1><span class="header-section-number">3.3</span> Compound Values: Operators</h1>
<blockquote>
<p>How many is three plus two?</p>
</blockquote>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="dv">3</span> + <span class="dv">2</span>
res2: Int = <span class="dv">5</span></code></pre>
<blockquote>
<p>What is the result of the concatenation of the texts “Hello ” and “world!”?</p>
</blockquote>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="st">&quot;Hello &quot;</span> ++ <span class="st">&quot;world!&quot;</span>
res3: String = Hello world!</code></pre>
<ul>
<li>Values can be combined using <strong>operators</strong> to build more complex values.</li>
</ul>
</div><div id="compound-values-method-calls" class="slide section level2">
<h1><span class="header-section-number">3.4</span> Compound Values: Method Calls</h1>
<blockquote>
<p>What is the size of the text “Hello world!”?</p>
</blockquote>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="st">&quot;Hello world!&quot;</span>.<span class="fu">size</span>
res4: Int = <span class="dv">12</span></code></pre>
<ul>
<li><strong>Methods</strong> are <strong>applied</strong> on values using the <strong>dot notation</strong>.</li>
</ul>
<blockquote>
<p>What is the range of numbers between 1 and 10?</p>
</blockquote>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="fl">1.</span><span class="fu">to</span>(<span class="dv">10</span>)
res5: scala.<span class="fu">collection</span>.<span class="fu">immutable</span>.<span class="fu">Range</span>.<span class="fu">Inclusive</span> = <span class="fu">Range</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>)</code></pre>
<ul>
<li>Methods can have <strong>parameters</strong>. They are supplied between parentheses.</li>
</ul>
</div><div id="operators-are-methods" class="slide section level2">
<h1><span class="header-section-number">3.5</span> Operators Are Methods</h1>
<p>Actually, operators are just methods with symbolic names:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="dv">3</span>.+(<span class="dv">2</span>)
res6: Int = <span class="dv">5</span></code></pre>
<p>The <strong>infix syntax</strong> can be used with non-symbolic methods too:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="dv">1</span> to <span class="dv">10</span>
res7: scala.<span class="fu">collection</span>.<span class="fu">immutable</span>.<span class="fu">Range</span>.<span class="fu">Inclusive</span> = <span class="fu">Range</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>)</code></pre>
<ul>
<li>The <strong>unification</strong> of methods and operators makes the language simpler.</li>
</ul>
</div><div id="exercises" class="slide section level2">
<h1><span class="header-section-number">3.6</span> Exercises</h1>
<ul>
<li><p>Use the <code>abs</code> method to get the absolute value of <code>-42</code>.</p></li>
<li><p>Use the <code>toUpperCase</code> method to get the text “Hello world!” in upper case.</p></li>
</ul>
</div><div id="raising-the-abstraction-level-non-literal-values" class="slide section level2">
<h1><span class="header-section-number">3.7</span> Raising the Abstraction Level: Non-Literal Values</h1>
<p>Until now you worked essentially with numbers and text. But how to define things of a higher-level like <strong>images</strong>?</p>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="fu">Circle</span>(<span class="dv">42</span>)
res8: doodle.<span class="fu">core</span>.<span class="fu">Circle</span> = <span class="fu">Circle</span>(<span class="fl">42.0</span>)</code></pre>
<p><code>Circle</code> is a <strong>constructor</strong> that takes one parameter (the radius) and returns a object representing a circle.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; Rectangle(<span class="dv">30</span>, <span class="dv">50</span>)
res9: doodle.<span class="fu">core</span>.<span class="fu">Rectangle</span> = Rectangle(<span class="fl">30.0</span>, <span class="fl">50.0</span>)</code></pre>
</div><div id="manipulating-images-display-and-layout" class="slide section level2">
<h1><span class="header-section-number">3.8</span> Manipulating Images: Display and Layout</h1>
<ul>
<li>Show an image with <code>draw</code>:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="fu">draw</span>(Rectangle(<span class="dv">30</span>, <span class="dv">50</span>))</code></pre>
<ul>
<li>Layout images by combining them using <code>beside</code>, <code>above</code> and <code>under</code>:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; Rectangle(<span class="dv">60</span>, <span class="dv">100</span>) beside <span class="fu">Circle</span>(<span class="dv">30</span>)
res10: doodle.<span class="fu">core</span>.<span class="fu">Image</span> = <span class="fu">Beside</span>(Rectangle(<span class="fl">60.0</span>,<span class="fl">100.0</span>),<span class="fu">Circle</span>(<span class="fl">30.0</span>))

scala&gt; <span class="fu">draw</span>(Rectangle(<span class="dv">60</span>, <span class="dv">100</span>) beside <span class="fu">Circle</span>(<span class="dv">30</span>))</code></pre>
</div><div id="types" class="slide section level2">
<h1><span class="header-section-number">3.9</span> Types</h1>
<ul>
<li>All values have a <strong>type</strong>:
<ul>
<li><code>42</code> has type <code>Int</code>,</li>
<li><code>&quot;foo&quot;</code> has type <code>String</code>.</li>
</ul></li>
<li>Types <strong>classify</strong> values;
<ul>
<li><code>0</code> and <code>42</code> are both <code>Int</code> values.</li>
</ul></li>
</ul>
</div><div id="types-guide-you" class="slide section level2">
<h1><span class="header-section-number">3.10</span> Types Guide You</h1>
<ul>
<li>Type checking forbids you to combine values in a wrong way:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="dv">1</span> to <span class="st">&quot;10&quot;</span>
&lt;console&gt;:<span class="dv">20</span>: error: <span class="kw">type</span> mismatch;
 found   : String(<span class="st">&quot;10&quot;</span>)
 required: Int
              <span class="dv">1</span> to <span class="st">&quot;10&quot;</span>
                   ^</code></pre>
<ul>
<li>Program execution is a two steps process:
<ul>
<li>First, the compiler transforms your Scala code into JVM bytecode,</li>
<li>Second, the JVM runs the bytecode.</li>
</ul></li>
<li>Type checking happens during the first step: errors are detected early.</li>
</ul>
</div><div id="some-common-types" class="slide section level2">
<h1><span class="header-section-number">3.11</span> Some Common Types</h1>
<p><code>Int</code> : a 32-bit signed integer</p>
<p><code>Double</code> : a 64-bit IEEE-754 floating point number (e.g. <code>12.34</code>).</p>
<p><code>Boolean</code> : boolean values (<code>true</code> and <code>false</code>)</p>
<p><code>String</code> : text</p>
</div><div id="the-type-meaning-the-absence-of-meaningful-value" class="slide section level2">
<h1><span class="header-section-number">3.12</span> The Type Meaning the Absence of (Meaningful) Value</h1>
<ul>
<li>Methods like <code>println</code> or <code>draw</code> return no meaningful value</li>
<li>Instead, they perform some <strong>side-effects</strong></li>
<li>Their return type is <code>Unit</code></li>
<li>There is only one value of type <code>Unit</code>: <code>()</code></li>
</ul>
</div><div id="exercise" class="slide section level2">
<h1><span class="header-section-number">3.13</span> Exercise</h1>
<ul>
<li>Draw an exclamation mark.</li>
</ul>
<div class="figure">
<img src="exclamation.png" />
</div>
</div><div id="exercise-1" class="slide section level2">
<h1><span class="header-section-number">3.14</span> Exercise</h1>
<ul>
<li>Draw a barbell.</li>
</ul>
<div class="figure">
<img src="barbell.png" />
</div>
</div><div id="manipulating-images-colors" class="slide section level2">
<h1><span class="header-section-number">3.15</span> Manipulating Images: Colors</h1>
<p>Use <code>fillColor</code> to fill an image with a given color:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">draw</span>(Rectangle(<span class="dv">30</span>, <span class="dv">80</span>) fillColor Color.<span class="fu">black</span>)</code></pre>
<p>Examples of available colors are <code>red</code>, <code>blue</code>, <code>green</code>, <code>black</code>, <code>white</code>, <code>gray</code> and <code>brown</code>.</p>
</div><div id="exercise-2" class="slide section level2">
<h1><span class="header-section-number">3.16</span> Exercise</h1>
<ul>
<li>Add colors to your barbell.</li>
</ul>
<div class="figure">
<img src="barbell-color.png" />
</div>
</div>
<div id="definitions" class="titleslide slide section level1"><h1><span class="header-section-number">4</span> Definitions</h1></div><div id="value-definitions" class="slide section level2">
<h1><span class="header-section-number">4.1</span> Value Definitions</h1>
<p>Consider the following program:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">draw</span>(
  (Rectangle(<span class="dv">25</span>, <span class="dv">100</span>) fillColor Color.<span class="fu">black</span>) beside
  (Rectangle(<span class="dv">200</span>, <span class="dv">20</span>) fillColor Color.<span class="fu">grey</span>) beside
  (Rectangle(<span class="dv">25</span>, <span class="dv">100</span>) fillColor Color.<span class="fu">black</span>)
)</code></pre>
<ul>
<li>It is hard to <strong>read</strong> because the expression is huge;</li>
<li>It is hard to <strong>maintain</strong>: if you want to change the width of the weights you have to change the code at <strong>two</strong> places.</li>
</ul>
</div><div id="value-definitions-2" class="slide section level2">
<h1><span class="header-section-number">4.2</span> Value Definitions (2)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> weight = Rectangle(<span class="dv">25</span>, <span class="dv">100</span>) fillColor Color.<span class="fu">black</span>

<span class="kw">val</span> bar = Rectangle(<span class="dv">200</span>, <span class="dv">20</span>) fillColor Color.<span class="fu">grey</span>

<span class="fu">draw</span>(weight beside bar beside weight)</code></pre>
<ul>
<li>The first two lines are <strong>value definitions</strong>. They:
<ul>
<li>introduce new <strong>names</strong> (<code>weight</code> and <code>bar</code>),</li>
<li><strong>bind</strong> them to the value at the right of “=”.</li>
</ul></li>
<li><p>Names can be used as any other value.</p></li>
<li><p>Note that the type of definitions is <strong>inferred</strong> by the compiler.</p></li>
</ul>
</div><div id="value-definitions-1" class="slide section level2">
<h1><span class="header-section-number">4.3</span> Value Definitions</h1>
<p>Now, changing the weights requires to modify the code at one place only:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> weight = Rectangle(<span class="dv">15</span>, <span class="dv">100</span>) fillColor Color.<span class="fu">black</span>

<span class="kw">val</span> bar = Rectangle(<span class="dv">200</span>, <span class="dv">20</span>) fillColor Color.<span class="fu">grey</span>

<span class="fu">draw</span>(weight beside bar beside weight)</code></pre>
</div><div id="exercise-3" class="slide section level2">
<h1><span class="header-section-number">4.4</span> Exercise</h1>
<ul>
<li>Draw two barbells one above the other. The first one must have small weights, while the second one must have heavy weights.</li>
</ul>
<div class="figure">
<img src="barbells.png" />
</div>
</div><div id="method-definitions" class="slide section level2">
<h1><span class="header-section-number">4.5</span> Method Definitions</h1>
<p>Consider the following program:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> heavyWeight = Rectangle(<span class="dv">30</span>, <span class="dv">100</span>) fillColor Color.<span class="fu">black</span>
<span class="kw">val</span> smallWeight = Rectangle(<span class="dv">15</span>, <span class="dv">100</span>) fillColor Color.<span class="fu">black</span>
<span class="kw">val</span> bar = Rectangle(<span class="dv">200</span>, <span class="dv">20</span>) fillColor Color.<span class="fu">grey</span>

<span class="kw">val</span> smallBarbell = smallWeight beside bar beside smallWeight
<span class="kw">val</span> heavyBarbell = heavyWeight beside bar beside heavyWeight

<span class="fu">draw</span>(smallBarbell above heavyBarbell)</code></pre>
<p>Note the similarities between the <code>heavyWeight</code> and <code>smallWeight</code> definitions. How could you <strong>generalize</strong> them?</p>
</div><div id="method-definitions-2" class="slide section level2">
<h1><span class="header-section-number">4.6</span> Method Definitions (2)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">weight</span>(width: Int) = Rectangle(width, <span class="dv">100</span>) fillColor Color.<span class="fu">black</span>

<span class="kw">val</span> heavyWeight = <span class="fu">weight</span>(<span class="dv">30</span>)
<span class="kw">val</span> smallWeight = <span class="fu">weight</span>(<span class="dv">15</span>)</code></pre>
<ul>
<li>The first line is a <strong>method definition</strong>. Contrary to value definitions, method definitions can have <strong>parameters</strong>.</li>
<li>Parameters are specified between parentheses, separated by a comma.</li>
<li>Parameter’s type must be explicitly given.</li>
</ul>
</div><div id="abstraction-principle" class="slide section level2">
<h1><span class="header-section-number">4.7</span> Abstraction Principle</h1>
<blockquote>
<p>Each significant piece of functionality in a program should be implemented in just one place in the source code.</p>
<p>Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by <strong>abstracting</strong> out the varying parts.</p>
</blockquote>
<p>Benjamin C. Pierce. <em>Types and Programming Languages</em>. MIT Press 2002.</p>
</div><div id="exercise-4" class="slide section level2">
<h1><span class="header-section-number">4.8</span> Exercise</h1>
<ul>
<li><p>Define a method <code>barbell</code> that takes as parameter an image of a weight and returns an image of a barbell with this weight.</p></li>
<li><p>Rewrite your previous program using the methods <code>barbell</code> and <code>weight</code>.</p></li>
</ul>
<!--
def barbell(weight: Image) =
  weight beside (Rectangle(200, 20) fillColor Color.grey) beside weight

def weight(width: Int) = Rectangle(width, 100) fillColor Color.black

val heavyBarbell = barbell(weight(30))
val smallBarbell = barbell(weight(15))

draw(smallBarbell above heavyBarbell)
-->

</div><div id="elements-of-programming" class="slide section level2">
<h1><span class="header-section-number">4.9</span> Elements of Programming</h1>
<ul>
<li>The programming language gives us ways to:
<ul>
<li>write literal values representing <strong>simple elements</strong> (<code>42</code>, <code>&quot;Hello &quot;</code>, etc.)</li>
<li><strong>combine</strong> these values (using methods)</li>
<li><strong>abstract</strong> over the value of expressions, by introducing a name to refer to an expression
<ul>
<li>These names can themselve abstract over parts of their definition, using parameters</li>
</ul></li>
</ul></li>
<li>These means of abstraction and composition give you <strong>expression power</strong> to generalize programs and combine them</li>
</ul>
</div>
<div id="loops-and-conditionals" class="titleslide slide section level1"><h1><span class="header-section-number">5</span> Loops and Conditionals</h1></div><div id="exercise-5" class="slide section level2">
<h1><span class="header-section-number">5.1</span> Exercise</h1>
<ul>
<li>Draw five barbells stacked on top of each other.</li>
</ul>
</div><div id="loops-and-conditionals-1" class="slide section level2">
<h1><span class="header-section-number">5.2</span> Loops and Conditionals</h1>
<p>Consider the following program:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> <span class="dt">unit</span> = <span class="fu">barbell</span>(<span class="fu">weight</span>(<span class="dv">15</span>))
<span class="kw">val</span> barbell1 = <span class="dt">unit</span>
<span class="kw">val</span> barbell2 = <span class="dt">unit</span> above barbell1
<span class="kw">val</span> barbell3 = <span class="dt">unit</span> above barbell2
<span class="kw">val</span> barbell4 = <span class="dt">unit</span> above barbell3
<span class="kw">val</span> barbell5 = <span class="dt">unit</span> above barbell4</code></pre>
<p>Note pattern: each <span class="math"><em>b</em><em>a</em><em>r</em><em>b</em><em>e</em><em>l</em><em>l</em><sub><em>n</em></sub></span> value is built by putting a barbell above the <span class="math"><em>b</em><em>a</em><em>r</em><em>b</em><em>e</em><em>l</em><em>l</em><sub><em>n</em> − 1</sub></span> value. How to <strong>generalize</strong> this pattern?</p>
</div><div id="loops-and-conditionals-2" class="slide section level2">
<h1><span class="header-section-number">5.3</span> Loops and Conditionals</h1>
<p>Basically, we want to express the following:</p>
<ul>
<li><span class="math"><em>b</em><em>a</em><em>r</em><em>b</em><em>e</em><em>l</em><em>l</em><sub><em>n</em></sub> = </span>
<ul>
<li><span class="math"><em>u</em><em>n</em><em>i</em><em>t</em></span> if <span class="math"><em>n</em> = 1</span>,</li>
<li><span class="math"><em>u</em><em>n</em><em>i</em><em>t</em></span> <span class="math"><em>a</em><em>b</em><em>o</em><em>v</em><em>e</em></span> <span class="math"><em>b</em><em>a</em><em>r</em><em>b</em><em>e</em><em>l</em><em>l</em><sub><em>n</em> − 1</sub></span> otherwise.</li>
</ul></li>
</ul>
</div><div id="conditional-expressions" class="slide section level2">
<h1><span class="header-section-number">5.4</span> Conditional Expressions</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> <span class="dt">unit</span> = <span class="fu">barbell</span>(<span class="fu">weight</span>(<span class="dv">15</span>))
<span class="kw">def</span> <span class="fu">barbells</span>(n: Int) =
  <span class="kw">if</span> (n == <span class="dv">1</span>) <span class="dt">unit</span>
  <span class="kw">else</span> <span class="dt">unit</span> above ???</code></pre>
<ul>
<li>You can write <strong>conditional expressions</strong> using <code>if</code> and <code>else</code></li>
<li>The result of a conditional depends on the <code>Boolean</code> value of the condition</li>
</ul>
</div><div id="boolean-expressions" class="slide section level2">
<h1><span class="header-section-number">5.5</span> Boolean Expressions</h1>
<ul>
<li>Boolean literals: <code>true</code> and <code>false</code></li>
<li>Comparison operator: <code>42 == 42</code>, <code>42 != 0</code>, <code>42 &gt; 0</code></li>
<li>Boolean expressions can be combined with <code>||</code> (disjonction), <code>&amp;&amp;</code> (conjonction), and <code>!</code> (negation)
<ul>
<li><code>true || false == !false</code></li>
</ul></li>
</ul>
</div><div id="recursive-methods" class="slide section level2">
<h1><span class="header-section-number">5.6</span> Recursive Methods</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> <span class="dt">unit</span> = <span class="fu">barbell</span>(<span class="fu">weight</span>(<span class="dv">15</span>))
<span class="kw">def</span> <span class="fu">barbells</span>(n: Int): Image =
  <span class="kw">if</span> (n == <span class="dv">1</span>) <span class="dt">unit</span>
  <span class="kw">else</span> <span class="dt">unit</span> above <span class="fu">barbells</span>(n - <span class="dv">1</span>)</code></pre>
<ul>
<li>The return type of <strong>recursive</strong> methods is mandatory.</li>
</ul>
</div><div id="recursive-methods-2" class="slide section level2">
<h1><span class="header-section-number">5.7</span> Recursive Methods (2)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="fu">barbells</span>(<span class="dv">3</span>)
res11: doodle.<span class="fu">core</span>.<span class="fu">Image</span> = <span class="fu">Above</span>(…)</code></pre>
<ul>
<li>What are the evaluation steps of the <code>barbells(3)</code> expression?</li>
</ul>
<ul class="incremental">
<li><p>Evaluation steps:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">barbells</span>(<span class="dv">3</span>)
<span class="kw">if</span> (<span class="dv">3</span> == <span class="dv">1</span>) <span class="dt">unit</span> <span class="kw">else</span> <span class="dt">unit</span> above <span class="fu">barbells</span>(<span class="dv">3</span> - <span class="dv">1</span>)
<span class="dt">unit</span> above <span class="fu">barbells</span>(<span class="dv">2</span>)
<span class="dt">unit</span> <span class="fu">above</span> (<span class="kw">if</span> (<span class="dv">2</span> == <span class="dv">1</span>) <span class="dt">unit</span> <span class="kw">else</span> <span class="dt">unit</span> above <span class="fu">barbells</span>(<span class="dv">2</span> - <span class="dv">1</span>))
<span class="dt">unit</span> <span class="fu">above</span> (<span class="dt">unit</span> above <span class="fu">barbells</span>(<span class="dv">1</span>))
<span class="dt">unit</span> <span class="fu">above</span> (<span class="dt">unit</span> <span class="fu">above</span> (<span class="kw">if</span> (<span class="dv">1</span> == <span class="dv">1</span>) <span class="dt">unit</span> <span class="kw">else</span> <span class="dt">unit</span> above <span class="fu">barbells</span>(<span class="dv">1</span> - <span class="dv">1</span>)))
<span class="dt">unit</span> <span class="fu">above</span> (<span class="dt">unit</span> above <span class="dt">unit</span>)</code></pre></li>
</ul>
</div><div id="exercise-6" class="slide section level2">
<h1><span class="header-section-number">5.8</span> Exercise</h1>
<ul>
<li>Define a method <code>circles</code> that takes a number <code>n</code> as parameter and returns an image showing <code>n</code> concentric circles of increasing sizes.</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">circles</span>(n: Int): Image = ???</code></pre>
<div class="figure">
<img src="circles.png" />
</div>
<!--
def circles(n: Int): Image = {
  val circle = Circle(25 + 15 * n)
  if (n == 1) circle
  else circle on circles(n - 1)
}
-->

</div>
<div id="top-level-definitions-and-lexical-scopes" class="titleslide slide section level1"><h1><span class="header-section-number">6</span> Top-Level Definitions and Lexical Scopes</h1></div><div id="object-definition" class="slide section level2">
<h1><span class="header-section-number">6.1</span> Object Definition</h1>
<ul>
<li>In Scala programs, methods and values must be defined within a top-level definition:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Loops {
  <span class="kw">def</span> <span class="fu">circles</span>(n: Int): Image = ???
}</code></pre>
<ul>
<li>This code contains an <strong>object definition</strong>, which introduces the name <code>Loops</code></li>
<li><code>Loops</code> refers to an <strong>object</strong> with one method, <code>circles</code></li>
<li>The method <code>circles</code> can be reached from the outside using the usual dot notation: <code>Loops.circles(42)</code></li>
</ul>
</div><div id="packages" class="slide section level2">
<h1><span class="header-section-number">6.2</span> Packages</h1>
<ul>
<li>Object definitions can be organized in <strong>packages</strong>:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> core

<span class="kw">object</span> Loops { … }</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> std

<span class="kw">object</span> Lists { … }</code></pre>
</div><div id="packages-visibility" class="slide section level2">
<h1><span class="header-section-number">6.3</span> Packages Visibility</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> core

<span class="kw">object</span> Loops {
  <span class="kw">def</span> <span class="fu">circles</span>(n: Int): Image = ???
}</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> core

<span class="kw">object</span> Definitions {
  Loops.<span class="fu">circles</span>(<span class="dv">42</span>)
}</code></pre>
<ul>
<li>Names located in a package are visible from code located in the same package</li>
</ul>
</div><div id="packages-visibility-2" class="slide section level2">
<h1><span class="header-section-number">6.4</span> Packages Visibility (2)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> std

<span class="kw">object</span> Lists {
  core.<span class="fu">Loops</span>.<span class="fu">circles</span>(<span class="dv">42</span>)
}</code></pre>
<ul>
<li>Names located in a package are not visible from code located in other packages</li>
<li>These names must be <strong>fully qualified</strong> to be resolved by the compiler</li>
</ul>
</div><div id="imports" class="slide section level2">
<h1><span class="header-section-number">6.5</span> Imports</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> std

<span class="kw">import</span> core.<span class="fu">Loops</span>

<span class="kw">object</span> Lists {
  Loops.<span class="fu">circles</span>(<span class="dv">42</span>)
}</code></pre>
<ul>
<li><strong>Import</strong> clauses make names available without qualification</li>
</ul>
</div><div id="blocks-and-local-definitions" class="slide section level2">
<h1><span class="header-section-number">6.6</span> Blocks and Local Definitions</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">barbells</span>(n: Int): Image = {
  <span class="kw">val</span> <span class="dt">unit</span> = <span class="fu">barbell</span>(<span class="fu">weight</span>(<span class="dv">15</span>))
  <span class="kw">if</span> (n == <span class="dv">1</span>) <span class="dt">unit</span>
  <span class="kw">else</span> <span class="dt">unit</span> above <span class="fu">barbells</span>(n - <span class="dv">1</span>)
}</code></pre>
<ul>
<li>Methods and values can also be defined within a <strong>block</strong></li>
<li>These local definitions are not visible from the outside of the block</li>
</ul>
</div><div id="exercise-7" class="slide section level2">
<h1><span class="header-section-number">6.7</span> Exercise</h1>
<ul>
<li>Define a method <code>spiral</code> that takes a number <code>n</code> as parameter and returns an image showing <code>n</code> circles of increasing sizes and laid out in a shape of spiral.</li>
</ul>
<div class="figure">
<img src="spiral.png" />
</div>
<!--
def spiral(n: Int): Image = {
  val size = 10 + n * 2
  val dist = 50 + n * 5
  val angle = Angle.degrees((n * 36) % 360)
  val circle = Circle(size).at(dist * angle.sin, dist * angle.cos)
  if (n == 1) circle else circle on spiral(n - 1)
}
-->

</div><div id="exercise-8" class="slide section level2">
<h1><span class="header-section-number">6.8</span> Exercise</h1>
<ul>
<li>Define a method <code>sierpinski</code> that takes a number <code>n</code> as parameter and returns an image showing the <em>Sierpinski triangle</em> at <code>n</code> iterations:</li>
</ul>
<div class="figure">
<img src="sierpinski.png" />
</div>
<!--
def sierpinski(n: Int): Image = {
  if(n == 1) {
    Triangle(10, 10) fillColor Color.black
  } else {
    val smaller = sierpinski(n - 1)
    smaller above (smaller beside smaller)
  }
}
-->

</div>
<div id="syntax-summary" class="titleslide slide section level1"><h1><span class="header-section-number">7</span> Syntax Summary</h1></div><div id="definitions-1" class="slide section level2">
<h1><span class="header-section-number">7.1</span> Definitions</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> &lt;name&gt; {
  &lt;statements&gt;
}</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> &lt;name&gt; = &lt;expr&gt;</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> &lt;name&gt;(&lt;p1&gt;, &lt;p2&gt;, …) = &lt;expr&gt;</code></pre>
</div><div id="expressions" class="slide section level2">
<h1><span class="header-section-number">7.2</span> Expressions</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> (&lt;expr&gt;) &lt;expr&gt; <span class="kw">else</span> &lt;expr&gt;</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala">&lt;name&gt;(&lt;expr&gt;, &lt;expr&gt;, …)</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala">&lt;expr&gt;.&lt;name&gt;(&lt;expr&gt;, …)</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala">{ &lt;expr&gt; ; … ; &lt;expr&gt; }</code></pre>
</div>
<div id="evaluation-model" class="titleslide slide section level1"><h1><span class="header-section-number">8</span> Evaluation Model</h1></div><div id="evaluation-model-1" class="slide section level2">
<h1><span class="header-section-number">8.1</span> Evaluation Model</h1>
<p>Consider the following program:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> foo = <span class="dv">1</span> + <span class="dv">1</span>
<span class="kw">val</span> bar = <span class="dv">1</span> + <span class="dv">1</span></code></pre>
<p>What is the difference between <code>foo</code> and <code>bar</code>?</p>
<ul class="incremental">
<li>The right hand side of <code>def</code>s is evaluated <strong>each</strong> time their name appear in an expression
<ul class="incremental">
<li><code>foo</code> refers to the expression <code>1 + 1</code></li>
</ul></li>
<li>The right hand side of <code>val</code>s is evaluated <strong>once</strong>, at the definition site
<ul class="incremental">
<li><code>bar</code> refers to the value <code>2</code></li>
</ul></li>
</ul>
</div><div id="termination" class="slide section level2">
<h1><span class="header-section-number">8.2</span> Termination</h1>
<p>Is the evaluation process guaranteed to terminate?</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> loop: Nothing = loop</code></pre>
<!--
## Linear and Tail Recursion

TODO
-->

</div>
<div id="higher-order-functions-and-function-literals" class="titleslide slide section level1"><h1><span class="header-section-number">9</span> Higher-Order Functions and Function Literals</h1></div><div id="motivation" class="slide section level2">
<h1><span class="header-section-number">9.1</span> Motivation</h1>
<p>Consider the following solutions to the circles and spiral exercises:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">circles</span>(n: Int): Image = {
  <span class="kw">val</span> circle = <span class="fu">Circle</span>(<span class="dv">25</span> + <span class="dv">15</span> * n)
  <span class="kw">if</span> (n == <span class="dv">1</span>) circle <span class="kw">else</span> circle on <span class="fu">circles</span>(n - <span class="dv">1</span>)
}

<span class="kw">def</span> <span class="fu">spiral</span>(n: Int): Image = {
  <span class="kw">val</span> size = <span class="dv">10</span> + n * <span class="dv">2</span>
  <span class="kw">val</span> dist = <span class="dv">50</span> + n * <span class="dv">5</span>
  <span class="kw">val</span> angle = Angle.<span class="fu">degrees</span>((n * <span class="dv">36</span>) % <span class="dv">360</span>)
  <span class="kw">val</span> circle = <span class="fu">Circle</span>(size).<span class="fu">at</span>(dist * angle.<span class="fu">sin</span>, dist * angle.<span class="fu">cos</span>)
  <span class="kw">if</span> (n == <span class="dv">1</span>) circle <span class="kw">else</span> circle on <span class="fu">spiral</span>(n - <span class="dv">1</span>)
}</code></pre>
<ul>
<li>Note the similarities between the last line of each method</li>
</ul>
</div><div id="motivation-2" class="slide section level2">
<h1><span class="header-section-number">9.2</span> Motivation (2)</h1>
<p>Here is an attempt to capture the loop and abstract over the images:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">stack</span>(image: Image, n: Int): Image =
  <span class="kw">if</span> (n == <span class="dv">1</span>) image <span class="kw">else</span> image on <span class="fu">stack</span>(image, n - <span class="dv">1</span>)

<span class="kw">def</span> <span class="fu">circles</span>(count: Int) = <span class="fu">stack</span>(???, count)</code></pre>
<ul class="incremental">
<li>We see that we can not supply the <code>image</code> parameter because it depends on the value of <code>n</code></li>
<li>How to abstract over the <strong>computation</strong> that returns the image?</li>
</ul>
</div><div id="abstract-over-computations" class="slide section level2">
<h1><span class="header-section-number">9.3</span> Abstract Over Computations</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">stack</span>(image: Int =&gt; Image, n: Int): Image =
  <span class="kw">if</span> (n == <span class="dv">1</span>) <span class="fu">image</span>(n) <span class="kw">else</span> <span class="fu">image</span>(n) on <span class="fu">stack</span>(n - <span class="dv">1</span>)

<span class="kw">def</span> <span class="fu">circles</span>(count: Int) = <span class="fu">stack</span>(n =&gt; <span class="fu">Circle</span>(<span class="dv">25</span> + <span class="dv">15</span> * n), count)</code></pre>
<ul>
<li>The parameter <code>image</code> has type <code>Int =&gt; Image</code>, that is a <strong>function</strong> taking an <code>Int</code> and returning an <code>Image</code></li>
<li>We define <code>circles</code> by supplying a <strong>function literal</strong></li>
</ul>
</div><div id="function-types-and-function-values" class="slide section level2">
<h1><span class="header-section-number">9.4</span> Function Types and Function Values</h1>
<ul>
<li>The type <code>(T1, …, Tn) =&gt; R</code> is the type of a function that takes <code>n</code> parameters (of type <code>T1</code>, …, <code>Tn</code>) and returns a value of type <code>R</code>
<ul>
<li><code>Int =&gt; Int</code> is the type of a function that takes an <code>Int</code> and returns an <code>Int</code></li>
</ul></li>
<li>The value <code>(t: T1, …, tn: Tn) =&gt; &lt;expr&gt;</code> is a function that takes <code>n</code> parameters (<code>t1</code>, …, <code>tn</code>) and which body is <code>&lt;expr&gt;</code>
<ul>
<li><code>(a: Int, b: Int) =&gt; a + b</code> is a function that takes two parameters <code>a</code> and <code>b</code> and returns their sum</li>
</ul></li>
</ul>
</div><div id="exercise-9" class="slide section level2">
<h1><span class="header-section-number">9.5</span> Exercise</h1>
<ul>
<li>Rewrite <code>spiral</code> using <code>stack</code></li>
</ul>
<!--
def spiral(count: Int) = stack(n => {
  val size = 10 + n * 2
  val dist = 50 + n * 5
  val angle = Angle.degrees((n * 36) % 360)
  Circle(size).at(dist * angle.sin, dist * angle.cos)
}, count)
-->

</div><div id="exercise-10" class="slide section level2">
<h1><span class="header-section-number">9.6</span> Exercise</h1>
<ul>
<li>Note the similarities between <code>stack</code> and <code>barbells</code>. Abstract over their differences by defining the following <code>layout</code> method:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">layout</span>(op: (Image, Image) =&gt; Image, image: Int =&gt; Image, n: Int): Image</code></pre>
<p>So that <code>stack</code> and <code>barbells</code> can be rewritten as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">stack</span>(image: Int =&gt; Image, count: Int) =
  <span class="fu">layout</span>((img1, img2) =&gt; img1 on img2, image, count)

<span class="kw">def</span> <span class="fu">barbells</span>(count: Int) =
  <span class="fu">layout</span>((img1, img2) =&gt; img1 above img2, n =&gt; <span class="fu">barbell</span>(<span class="fu">weight</span>(<span class="dv">15</span>)), count)</code></pre>
<!--
def layout(op: (Image, Image) => Image, image: Int => Image, n: Int): Image =
  if (n == 1) image(n) else op(image(n), layout(op, image, n - 1))
-->

</div><div id="exercise-11" class="slide section level2">
<h1><span class="header-section-number">9.7</span> Exercise</h1>
<ul>
<li>Rewrite <code>sierpinski</code> using <code>layout</code></li>
</ul>
<!--
def sierpinski(count: Int) =
  layout((img1, img2) => img2 above (img2 beside img2), n => Triangle(10, 10) fillColor Color.black, count)
-->



</div>
<div id="making-standalone-programs" class="titleslide slide section level1"><h1><span class="header-section-number">10</span> Making Standalone Programs</h1></div><div id="making-a-standalone-program-from-a-source-file" class="slide section level2">
<h1><span class="header-section-number">10.1</span> Making a Standalone Program from a Source File</h1>
<ul>
<li>Write the following program in a file <code>Main.scala</code>:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Main <span class="kw">extends</span> App {

  <span class="fu">println</span>(<span class="st">&quot;Hello world!&quot;</span>)

}</code></pre>
</div><div id="making-an-executable-program-from-a-source-file-2" class="slide section level2">
<h1><span class="header-section-number">10.2</span> Making an Executable Program from a Source File (2)</h1>
<ul>
<li>Compile it:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">scalac</span> Main.scala</code></pre>
<p>(it should produce <code>*.class</code> files)</p>
<ul>
<li>Run it:</li>
</ul>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">scala</span> Main
<span class="st">&quot;Hello world!&quot;</span></code></pre>
</div><div id="scaling-the-build-process" class="slide section level2">
<h1><span class="header-section-number">10.3</span> Scaling the Build Process</h1>
<ul>
<li><p>What if your program has 100 source files?</p></li>
<li><p>How to recompile only the sources impacted by a given modification?</p></li>
<li><p>What if your project depends on a third-party library?</p></li>
<li><p>How to handle a whole project lifecycle (testing, packaging, publishing, etc.)?</p></li>
</ul>
</div><div id="sbt" class="slide section level2">
<h1><span class="header-section-number">10.4</span> sbt</h1>
<p><a href="http://www.scala-sbt.org/">sbt</a> is a build tool for Scala (and Java) projects</p>
</div><div id="sbt-quick-start" class="slide section level2">
<h1><span class="header-section-number">10.5</span> sbt Quick Start</h1>
<ul>
<li><p>Run <code>$ sbt &lt;command&gt;</code> from your project directory to run an sbt command from your shell</p></li>
<li><p>Run <code>$ sbt</code> from your project directory to open the sbt prompt</p></li>
<li><p>Run sbt commands from the sbt prompt</p>
<ul>
<li><code>&gt; run</code> to run your project</li>
<li><code>&gt; console</code> to open a Scala REPL in the context of your project</li>
<li><code>&gt; test</code> to run the tests of your project</li>
<li><code>&gt; compile</code> to compile your project (without running it)</li>
</ul></li>
</ul>
</div><div id="sbt-quick-start-2" class="slide section level2">
<h1><span class="header-section-number">10.6</span> sbt Quick Start (2)</h1>
<ul>
<li>The build process of the project is defined in a <code>build.sbt</code> file</li>
<li><p>This file essentially defines your project’s <strong>settings</strong>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">name := <span class="st">&quot;my-project&quot;</span>

version := <span class="st">&quot;1.0&quot;</span>

libraryDependencies += <span class="st">&quot;com.chuusai&quot;</span> %% <span class="st">&quot;shapeless&quot;</span> % <span class="st">&quot;2.1.0&quot;</span></code></pre></li>
<li><p>Settings values are Scala expressions</p></li>
</ul>
</div>
<div id="modeling-the-world" class="titleslide slide section level1"><h1><span class="header-section-number">11</span> Modeling the World</h1></div><div id="motivation-1" class="slide section level2">
<h1><span class="header-section-number">11.1</span> Motivation</h1>
<ul>
<li>Consider the following <code>barbell</code> method that creates a barbell:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">barbell</span>(load: Int, length: Int): Image = {
  <span class="kw">val</span> weight = Rectangle(load, <span class="dv">100</span>) fillColor Color.<span class="fu">black</span>
  <span class="kw">val</span> bar = Rectangle(length, <span class="dv">20</span>) fillColor Color.<span class="fu">grey</span>
  weight beside bar beside weight
}

<span class="kw">val</span> lightBarbell = <span class="fu">barbell</span>(<span class="dv">10</span>, <span class="dv">180</span>)
<span class="kw">val</span> heavyBarbell = <span class="fu">barbell</span>(<span class="dv">20</span>, <span class="dv">200</span>)</code></pre>
<ul>
<li>You can’t do much with your barbells (excepted drawing them)</li>
</ul>
</div><div id="motivation-2-1" class="slide section level2">
<h1><span class="header-section-number">11.2</span> Motivation (2)</h1>
<ul>
<li>How to define a barbell heavier than a given barbell?</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">weigh</span>(barbell: Image): Image = ???</code></pre>
<ul class="incremental">
<li>Modeling barbells with images makes it hard to manipulate them</li>
</ul>
</div><div id="motivation-3" class="slide section level2">
<h1><span class="header-section-number">11.3</span> Motivation (3)</h1>
<ul>
<li>How to define a barbell heavier than a given barbell?</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">weighLoad</span>(load: Int) = load + <span class="dv">10</span>
<span class="kw">def</span> <span class="fu">weighLength</span>(length: Int) = length + <span class="dv">20</span>

<span class="kw">val</span> lightBarbellLoad = <span class="dv">10</span>
<span class="kw">val</span> lightBarbellLength = <span class="dv">180</span>

<span class="kw">val</span> heavyBarbellLoad = <span class="fu">weighLoad</span>(lightBarbellLoad)
<span class="kw">val</span> heavyBarbellLength = <span class="fu">weighLength</span>(lightBarbellLength)</code></pre>
<ul class="incremental">
<li>This approach is such a mess to use</li>
</ul>
</div><div id="case-class-definition" class="slide section level2">
<h1><span class="header-section-number">11.4</span> Case Class Definition</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">Barbell</span>(load: Int, length: Int) {
  <span class="kw">def</span> weigh: Barbell = <span class="fu">Barbell</span>(load + <span class="dv">10</span>, length + <span class="dv">20</span>)
}

<span class="kw">val</span> lightBarbell = <span class="fu">Barbell</span>(<span class="dv">10</span>, <span class="dv">180</span>)
<span class="kw">val</span> heavyBarbell = lightBarbell.<span class="fu">weigh</span></code></pre>
<ul>
<li>This code contains a <strong>case class definition</strong> which introduces:
<ul>
<li>the <code>Barbell</code> <strong>type</strong>,</li>
<li>the <code>Barbell</code> <strong>constructor</strong></li>
</ul></li>
</ul>
</div><div id="case-class-definition-2" class="slide section level2">
<h1><span class="header-section-number">11.5</span> Case Class Definition (2)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">Barbell</span>(load: Int, length: Int) {
  <span class="kw">def</span> weigh: Barbell = <span class="fu">Barbell</span>(load + <span class="dv">10</span>, length + <span class="dv">20</span>)
}

<span class="kw">val</span> lightBarbell = <span class="fu">Barbell</span>(<span class="dv">10</span>, <span class="dv">180</span>)
<span class="kw">val</span> heavyBarbell = lightBarbell.<span class="fu">weigh</span></code></pre>
<ul>
<li>The <code>Barbell</code> type has three <strong>members</strong>: <code>load</code>, <code>length</code> and <code>weigh</code></li>
<li><code>lightBarbell</code> and <code>heavyBarbell</code> are <strong>instances</strong> of <code>Barbell</code></li>
</ul>
</div><div id="exercise-12" class="slide section level2">
<h1><span class="header-section-number">11.6</span> Exercise</h1>
<ul>
<li>Implement the following method:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">barbellImage</span>(barbell: Barbell): Image = ???</code></pre>
</div><div id="exercise-13" class="slide section level2">
<h1><span class="header-section-number">11.7</span> Exercise</h1>
<ul>
<li>Add a method <code>lighten</code> to the <code>Barbell</code> type</li>
</ul>
</div><div id="exercise-14" class="slide section level2">
<h1><span class="header-section-number">11.8</span> Exercise</h1>
<ul>
<li>A barbell is one possible fitness device</li>
<li>Consider also a simple mat as another type of fitness device:</li>
</ul>
<div class="figure">
<img src="mat.png" />
</div>
<ul>
<li>A mat has a width and a length. Define a case class for it.</li>
</ul>
</div><div id="exercise-15" class="slide section level2">
<h1><span class="header-section-number">11.9</span> Exercise</h1>
<ul>
<li>Let’s assume that in your world a fitness device is either a mat or a barbell (and nothing else)</li>
<li>Write a <code>fitnessDeviceImage</code> method that takes a fitness device as parameter and returns an image of it</li>
</ul>
</div><div id="variant-types" class="slide section level2">
<h1><span class="header-section-number">11.10</span> Variant Types</h1>
<ul>
<li>How to model that a fitness device can either be a mat or be a barbell, and nothing else?</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> FitnessDevice
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Barbell</span>(load: Int, length: Int) <span class="kw">extends</span> FitnessDevice
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Mat</span>(width: Int, length: Int) <span class="kw">extends</span> FitnessDevice</code></pre>
<ul>
<li>This code contains a <strong>sealed trait definition</strong>, which introduces the <code>FitnessDevice</code> type (but <strong>no</strong> constructor)</li>
<li>Case class definitions that <strong>extend</strong> <code>FitnessDevice</code> define the possible <strong>variants</strong> of <code>FitnessDevice</code>
<ul>
<li>The variants of a sealed type must be defined within the same source file</li>
</ul></li>
</ul>
</div><div id="pattern-matching" class="slide section level2">
<h1><span class="header-section-number">11.11</span> Pattern Matching</h1>
<p>You can manipulate case classes and sealed types using <strong>pattern matching</strong>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">name</span>(fitnessDevice: FitnessDevice): String = fitnessDevice <span class="kw">match</span> {
  <span class="kw">case</span> <span class="fu">Barbell</span>(load, length) =&gt; <span class="st">&quot;Barbell&quot;</span>
  <span class="kw">case</span> <span class="fu">Mat</span>(width, length) =&gt; <span class="st">&quot;Mat&quot;</span>
}</code></pre>
</div><div id="exercise-16" class="slide section level2">
<h1><span class="header-section-number">11.12</span> Exercise</h1>
<ul>
<li>Implement the following method:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">fitnessDeviceImage</span>(fitnessDevice: FitnessDevice): Image = ???</code></pre>
</div><div id="syntax-summary-1" class="slide section level2">
<h1><span class="header-section-number">11.13</span> Syntax Summary</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> &lt;name&gt;(&lt;member1&gt;, &lt;member2&gt;, …)</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> &lt;name1&gt;
<span class="kw">case</span> <span class="kw">class</span> &lt;name2&gt;(…) <span class="kw">extends</span> &lt;name1&gt;
<span class="kw">case</span> <span class="kw">class</span> &lt;name3&gt;(…) <span class="kw">extends</span> &lt;name1&gt;
…</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala">&lt;expr&gt; <span class="kw">match</span> {
  <span class="kw">case</span> &lt;name2&gt;(…) =&gt; &lt;expr&gt;
  <span class="kw">case</span> &lt;name3&gt;(…) =&gt; &lt;expr&gt;
}</code></pre>
</div>
<div id="handling-failure" class="titleslide slide section level1"><h1><span class="header-section-number">12</span> Handling Failure</h1></div><div id="motivation-4" class="slide section level2">
<h1><span class="header-section-number">12.1</span> Motivation</h1>
<p>Remember the <code>lighten</code> method:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> lighten = <span class="fu">Barbell</span>(load - <span class="dv">10</span>, length - <span class="dv">20</span>)</code></pre>
<ul class="incremental">
<li>What happens if the <code>load</code> or the <code>length</code> becomes zero or less?</li>
<li>Do you want <code>lighten</code> to be <strong>defined</strong> for <strong>all</strong> values of <code>Barbell</code>?</li>
</ul>
</div><div id="option" class="slide section level2">
<h1><span class="header-section-number">12.2</span> <code>Option</code></h1>
<p>A way to model the fact that a given barbell may not have a lighter barbell is to use the <code>Option</code> type:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> lighten: Option[Barbell] =
  <span class="kw">if</span> (load &lt;= <span class="dv">15</span> || length &lt;= <span class="dv">100</span>) None
  <span class="kw">else</span> Some(<span class="fu">Barbell</span>(load - <span class="dv">10</span>, length - <span class="dv">20</span>))</code></pre>
<ul>
<li>The standard library defines the type <code>Option[A]</code> that models an optional value of type <code>A</code></li>
<li>An <code>Option[A]</code> value can either be:
<ul>
<li><code>Some(a)</code></li>
<li><code>None</code></li>
</ul></li>
</ul>
</div><div id="exercise-17" class="slide section level2">
<h1><span class="header-section-number">12.3</span> Exercise</h1>
<ul>
<li>Add a <code>smaller</code> method to the <code>Mat</code> type:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> smaller: Option[Mat] = ???</code></pre>
</div><div id="common-patterns-with-optional-values" class="slide section level2">
<h1><span class="header-section-number">12.4</span> Common Patterns with Optional Values</h1>
<p><code>Option</code> values can be manipulated using pattern matching:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">whatIsIn</span>(maybeBarbell: Option[Barbell]): String =
  maybeBarbell <span class="kw">match</span> {
    <span class="kw">case</span> Some(barbell) =&gt; <span class="st">&quot;there is a barbell&quot;</span>
    <span class="kw">case</span> None =&gt; <span class="st">&quot;there is no barbell&quot;</span>
  }</code></pre>
</div><div id="common-patterns-with-optional-values-1" class="slide section level2">
<h1><span class="header-section-number">12.5</span> Common Patterns With Optional Values</h1>
<p>Use <code>map</code> to transform a successful value into another successful value, ignoring the <code>None</code> case:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">maybeWidth</span>(maybeMat: Option[Mat]): Option[Int] =
  maybeMat.<span class="fu">map</span>(mat =&gt; mat.<span class="fu">width</span>)</code></pre>
</div><div id="common-patterns-with-optional-values-2" class="slide section level2">
<h1><span class="header-section-number">12.6</span> Common Patterns With Optional Values (2)</h1>
<p>Use <code>filter</code> to turn a successful value into a failure if it does not satisfy a given predicate:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">keepHugeMats</span>(maybeMat: Option[Mat]): Option[Mat] =
  maybeMat.<span class="fu">filter</span>(mat =&gt; mat.<span class="fu">width</span> &gt; <span class="dv">100</span> &amp;&amp; mat.<span class="fu">length</span> &gt; <span class="dv">200</span>)</code></pre>
</div><div id="common-patterns-with-optional-values-3" class="slide section level2">
<h1><span class="header-section-number">12.7</span> Common Patterns With Optional Values (3)</h1>
<p>Use <code>flatMap</code> to transform a successful value into an optional value:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">smallerSmaller</span>(mat: Mat): Option[Mat] =
  mat.<span class="fu">smaller</span>.<span class="fu">flatMap</span>(smallerMat =&gt; smallerMat.<span class="fu">smaller</span>)</code></pre>
</div><div id="sequencing-computations-manipulating-optional-values" class="slide section level2">
<h1><span class="header-section-number">12.8</span> Sequencing Computations Manipulating Optional Values</h1>
<p><code>flatMap</code> and <code>map</code> are used to sequence computations operating on optional values:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">lightenLightenLoad</span>(barbell: Barbell): Option[Int] =
  barbell.<span class="fu">lighten</span>.<span class="fu">flatMap</span> { lighterBarbell =&gt;
    lighterBarbell.<span class="fu">lighten</span>.<span class="fu">map</span> { lighterLighterBarbell =&gt;
      lighterLighterBarell.<span class="fu">load</span>
    }
  }</code></pre>
<p>(We will see a more expressive way of expressing such computations, soon)</p>
</div><div id="try" class="slide section level2">
<h1><span class="header-section-number">12.9</span> <code>Try</code></h1>
<ul>
<li><code>Try[A]</code> is <em>similar</em> to <code>Option[A]</code> excepted that in case of failure it provides more information. It can either be:
<ul>
<li><code>Success(a)</code></li>
<li><code>Failure(throwable)</code></li>
</ul></li>
</ul>
</div><div id="common-patterns-with-trya-values" class="slide section level2">
<h1><span class="header-section-number">12.10</span> Common Patterns with <code>Try[A]</code> Values</h1>
<ul>
<li>Like <code>Option[A]</code>, <code>Try[A]</code> has <code>map</code>, <code>filter</code> and <code>flatMap</code></li>
</ul>
<!--
TODO Exceptions try/catch
-->

</div>
<div id="standard-collections" class="titleslide slide section level1"><h1><span class="header-section-number">13</span> Standard Collections</h1></div><div id="standard-collections-1" class="slide section level2">
<h1><span class="header-section-number">13.1</span> Standard Collections</h1>
<p>The Scala standard library provides several types making it easier to deal with collections of elements</p>
<p>This section gives a slight overview of the standard collections. For more details see the <a href="http://scala-lang.org/api">API documentation</a></p>
</div><div id="traversable" class="slide section level2">
<h1><span class="header-section-number">13.2</span> <code>Traversable</code></h1>
<p>The most general one is <code>Traversable[A]</code>, it provides methods to iterate on the elements of a collection, to transform a collection, to filter it, and a lot more:</p>
<table>
<thead>
<tr class="header">
<th align="left">Method</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>xs ++ ys</code></td>
<td align="left">The concatenation of the elements of <code>xs</code> and <code>ys</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs.size</code></td>
<td align="left">The number of elements in <code>xs</code></td>
</tr>
<tr class="odd">
<td align="left"><code>xs.map(f)</code></td>
<td align="left">A collection obtained from applying <code>f</code> to every element of <code>xs</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs.flatMap(f)</code></td>
<td align="left">A collection obtained from applying <code>f</code> to every element of <code>xs</code> and concatenating the results</td>
</tr>
<tr class="odd">
<td align="left"><code>xs.filter(p)</code></td>
<td align="left">A collection obtained from filtering elements of <code>xs</code> that satisfy the predicate <code>p</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs.foldleft(z)(f)</code></td>
<td align="left">Applies a binary operator <code>f</code> to a start value <code>z</code> and all elements of <code>xs</code>, going left to right</td>
</tr>
<tr class="odd">
<td align="left"><code>xs.take(n)</code></td>
<td align="left">A collection containing the <code>n</code> first elements of <code>xs</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs.find(p)</code></td>
<td align="left">An optional value containing the first element of <code>xs</code> that satisfies <code>p</code></td>
</tr>
<tr class="odd">
<td align="left"><code>xs.headOption</code></td>
<td align="left">An optional value containing the first element of <code>xs</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs.tailOption</code></td>
<td align="left">An optional value containing the tail of <code>xs</code></td>
</tr>
<tr class="odd">
<td align="left"><code>xs.foreach(f)</code></td>
<td align="left">Applies the function <code>f</code> to every element of <code>xs</code></td>
</tr>
</tbody>
</table>
</div><div id="iterable" class="slide section level2">
<h1><span class="header-section-number">13.3</span> <code>Iterable</code></h1>
<p><code>Iterable[A]</code> extends <code>Traversable[A]</code>, here are some of its new members:</p>
<table>
<thead>
<tr class="header">
<th align="left">Method</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>xs.iterator</code></td>
<td align="left">An <code>Iterator[A]</code> over the elements of <code>xs</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs.grouped(n)</code></td>
<td align="left">An iterator that yields fixed-size chunks of <code>xs</code></td>
</tr>
<tr class="odd">
<td align="left"><code>xs zip ys</code></td>
<td align="left">An iterable of pairs of corresponding elements of <code>xs</code> and <code>ys</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs.zipWithIndex</code></td>
<td align="left">An iterable of pairs of elements of <code>xs</code> with their indices</td>
</tr>
</tbody>
</table>
</div><div id="seq" class="slide section level2">
<h1><span class="header-section-number">13.4</span> <code>Seq</code></h1>
<p><code>Seq[A]</code> is an <code>Iterable[A]</code> which order of elements is kept. It adds the following members:</p>
<table>
<thead>
<tr class="header">
<th align="left">Method</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x +: xs</code></td>
<td align="left">A collection with the elements of <code>xs</code> prepended with <code>x</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs :+ x</code></td>
<td align="left">A collection with the elements of <code>xs</code> followed by <code>x</code></td>
</tr>
<tr class="odd">
<td align="left"><code>xs.get(n)</code></td>
<td align="left">An optional value containing the <code>n</code><sup>th</sup> element of <code>xs</code> (0 indicates the first element)</td>
</tr>
<tr class="even">
<td align="left"><code>xs.reverse</code></td>
<td align="left">A collection with the elements of <code>xs</code> in reverse order</td>
</tr>
<tr class="odd">
<td align="left"><code>xs.updated(n, x)</code></td>
<td align="left">A copy of <code>xs</code> which <code>n</code><sup>th</sup> element has been replaced by <code>x</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs.sorted</code></td>
<td align="left">A collection with the elements of <code>xs</code> sorted</td>
</tr>
</tbody>
</table>
</div><div id="seq-2" class="slide section level2">
<h1><span class="header-section-number">13.5</span> <code>Seq</code> (2)</h1>
<p>A <code>Seq</code> can be created simply using the <code>Seq</code> constructor:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> xs = Seq(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
<span class="kw">val</span> ys = Seq.<span class="fu">empty</span>[Int]</code></pre>
<p><code>Seq</code> can be used with pattern matching as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">sum</span>(xs: Seq[Int]): Int = xs <span class="kw">match</span> {
  <span class="kw">case</span> Nil     =&gt; <span class="dv">0</span>
  <span class="kw">case</span> x +: xs =&gt; x + <span class="fu">sum</span>(xs)
}</code></pre>
</div><div id="list-and-vector" class="slide section level2">
<h1><span class="header-section-number">13.6</span> <code>List</code> and <code>Vector</code></h1>
<p><code>List[A]</code> and <code>Vector[A]</code> are two implementations of <code>Seq[A]</code> with different performance characteristics:</p>
<ul>
<li><p><code>List[A]</code> has more efficient <code>head</code> and <code>tail</code> implementations</p></li>
<li><p><code>Vector[A]</code> has more efficient <code>get</code> and <code>size</code> implementations</p></li>
<li><p>If you want to do random access, you should use <code>Vector[A]</code></p></li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> xs = <span class="dv">1</span> :: <span class="dv">2</span> :: <span class="dv">3</span> :: Nil <span class="co">// List</span>
<span class="kw">val</span> ys = Vector(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</code></pre>
</div><div id="range" class="slide section level2">
<h1><span class="header-section-number">13.7</span> <code>Range</code></h1>
<p><code>Range</code> is a useful implementation of <code>Seq[Int]</code> that efficiently represents a range of integer values</p>
<p>The simplest way to generate a range is to use <code>to</code> and <code>until</code> methods of numeric values:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">(<span class="dv">1</span> to <span class="dv">3</span>).<span class="fu">foreach</span>(println) <span class="co">// prints “1”, “2”, “3”</span>
(<span class="dv">0</span> until <span class="dv">3</span>).<span class="fu">map</span>(_ * <span class="dv">2</span>).<span class="fu">foreach</span>(println) <span class="co">// prints “0”, “2”, “4”</span></code></pre>
</div><div id="set" class="slide section level2">
<h1><span class="header-section-number">13.8</span> <code>Set</code></h1>
<p>A <code>Set[A]</code> is an <code>Iterable[A]</code> that contains no duplicate elements. It adds the following members:</p>
<table>
<thead>
<tr class="header">
<th align="left">Method</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>xs + x</code></td>
<td align="left">A set containing the elements of <code>xs</code> and <code>x</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs - x</code></td>
<td align="left">A set containing the elements of <code>xs</code> without <code>x</code></td>
</tr>
<tr class="odd">
<td align="left"><code>xs.contains(x)</code></td>
<td align="left">Tests if <code>x</code> is contained in <code>xs</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs &amp; ys</code></td>
<td align="left">Intersection of <code>xs</code> and <code>ys</code></td>
</tr>
<tr class="odd">
<td align="left"><code>xs | ys</code></td>
<td align="left">Union of <code>xs</code> and <code>ys</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs.subsetOf(ys)</code></td>
<td align="left">Tests if <code>xs</code> is a subset of <code>ys</code></td>
</tr>
</tbody>
</table>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> xs = Set(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</code></pre>
</div><div id="map" class="slide section level2">
<h1><span class="header-section-number">13.9</span> <code>Map</code></h1>
<p>A <code>Map[A, B]</code> is an <code>Iterable[(A, B)]</code> that contains <code>B</code> values indexed by <code>A</code> values. It adds the following members:</p>
<table>
<thead>
<tr class="header">
<th align="left">Method</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>xs.get(k)</code></td>
<td align="left">An optional value containing the value associated with <code>k</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs + (k -&gt; x)</code></td>
<td align="left">Adds a new value <code>x</code> associated with <code>k</code></td>
</tr>
<tr class="odd">
<td align="left"><code>xs - k</code></td>
<td align="left">Removes the element associated with <code>k</code></td>
</tr>
<tr class="even">
<td align="left"><code>xs.keys</code></td>
<td align="left">An iterable of the keys of <code>xs</code></td>
</tr>
</tbody>
</table>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> xs = Map(<span class="st">&quot;foo&quot;</span> -&gt; <span class="dv">42</span>, <span class="st">&quot;bar&quot;</span> -&gt; <span class="dv">10</span>, <span class="st">&quot;baz&quot;</span> -&gt; <span class="dv">0</span>)</code></pre>
</div><div id="exercise-18" class="slide section level2">
<h1><span class="header-section-number">13.10</span> Exercise</h1>
<ul>
<li>Change the <code>circles</code> method so that it returns a collection of concentric circles:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">circles</span>(n: Int): Seq[Circle] = ???</code></pre>
<ul>
<li>Note: write to different implementations: a recursive and a non-recursive one.</li>
</ul>
<!--
def circles(n: Int): Seq[Circle] = {
  val unit = Circle(25 + 15 * n)
  if (n == 1) Seq(unit)
  else circles(n - 1) :+ unit
}

def circles(count: Int) =
  (1 to count) map { n =>
    Circle(25 + 15 * n)
  }
-->

</div><div id="exercise-19" class="slide section level2">
<h1><span class="header-section-number">13.11</span> Exercise</h1>
<ul>
<li>Do the same for <code>spiral</code>:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">spiral</span>(n: Int): Seq[Image] = ???</code></pre>
<!--
def spiral(count: Int) =
  (1 to count) map { n =>
    val size = 10 + n * 2
    val dist = 50 + n * 5
    val angle = Angle.degrees((n * 36) % 360)
    Circle(size).at(dist * angle.sin, dist * angle.cos)
  }
-->

</div><div id="exercise-20" class="slide section level2">
<h1><span class="header-section-number">13.12</span> Exercise</h1>
<ul>
<li>Change the <code>stack</code> method to the following:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">stack</span>(images: Seq[Image]): Image = ???</code></pre>
<ul>
<li>Note: write a recursive implementation and a non-recursive implementation</li>
</ul>
<!--
def stack(images: Seq[Image]): Image = images match {
  case Nil => emptyImage
  case image +: images => image on stack(images)
}

def stack(images: Seq[Image]): Image =
  images.foldLeft(emtyImage)((image, result) => image on result)
-->

</div><div id="exercise-21" class="slide section level2">
<h1><span class="header-section-number">13.13</span> Exercise</h1>
<ul>
<li>Change the <code>layout</code> method to the following:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">layout</span>(op: (Image, Image) =&gt; Image, images: Seq[Image]): Image = ???</code></pre>
<!--
def layout(op: (Image, Image) => Image, images: Seq[Image]): Image =
  images.foldLeft(emptyImage)(op)
-->

</div>
<div id="syntactic-sugars" class="titleslide slide section level1"><h1><span class="header-section-number">14</span> Syntactic Sugars</h1></div><div id="string-interpolation" class="slide section level2">
<h1><span class="header-section-number">14.1</span> String Interpolation</h1>
<p><strong>String interpolation</strong> is a mechanism to build strings from dynamic values:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">greet</span>(name: String) = s<span class="st">&quot;Hello, $name!&quot;</span></code></pre>
<ul>
<li><p>Prefix a string literal with <code>s</code></p></li>
<li><p>Within the string, use <code>$&lt;name&gt;</code> to insert a value</p></li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">greet</span>(<span class="st">&quot;World&quot;</span>) <span class="co">// &quot;Hello, World!&quot;</span></code></pre>
</div><div id="sequencing-computations" class="slide section level2">
<h1><span class="header-section-number">14.2</span> Sequencing Computations</h1>
<p>Actually, <code>flatMap</code> and <code>map</code> functions are very useful to sequence computations within a given <em>context</em> (optional values, collections, and much more)</p>
<p>They are so common that Scala supports a more convenient syntax, the <strong><code>for</code> notation</strong>, that desugars to <code>flatMap</code>, <code>map</code> and <code>filter</code> calls</p>
</div><div id="sequencing-computations-1" class="slide section level2">
<h1><span class="header-section-number">14.3</span> Sequencing Computations</h1>
<p>Remember the <code>lightenLightenLoad</code> method:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">lightenLightenLoad</span>(barbell: Barbell): Option[Int] =
  barbell.<span class="fu">lighten</span>.<span class="fu">flatMap</span> { lighterBarbell =&gt;
    lighterBarbell.<span class="fu">lighten</span>.<span class="fu">map</span> { lighterLighterBarbell =&gt;
      lighterLighterBarbell.<span class="fu">load</span>
    }
  }</code></pre>
<p>You can rewrite it as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">lightenLightenLoad</span>(barbell: Barbell): Option[Int] =
  <span class="kw">for</span> {
    lighterBarbell &lt;- barbell.<span class="fu">lighten</span>
    lighterLighterBarbell &lt;- lighterBarbell.<span class="fu">lighten</span>
  } <span class="kw">yield</span> lighterLighterBarbell.<span class="fu">load</span></code></pre>
</div><div id="translation-of-for" class="slide section level2">
<h1><span class="header-section-number">14.4</span> Translation of <code>for</code></h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> (x &lt;- xs) <span class="kw">yield</span> x + <span class="dv">1</span></code></pre>
<p>is translated to:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">xs.<span class="fu">map</span>(x =&gt; x + <span class="dv">1</span>)</code></pre>
</div><div id="translation-of-for-2" class="slide section level2">
<h1><span class="header-section-number">14.5</span> Translation of <code>for</code> (2)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> (x &lt;- xs; y &lt;- ys) <span class="kw">yield</span> (x, y)</code></pre>
<p>is translated to:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">xs.<span class="fu">flatMap</span>(x =&gt; <span class="kw">for</span> (y &lt;- ys) <span class="kw">yield</span> (x, y))</code></pre>
</div><div id="translation-of-for-3" class="slide section level2">
<h1><span class="header-section-number">14.6</span> Translation of <code>for</code> (3)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> (x &lt;- xs <span class="kw">if</span> x % <span class="dv">2</span> == <span class="dv">0</span>) <span class="kw">yield</span> x + <span class="dv">1</span></code></pre>
<p>is essentially translated to:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> (x &lt;- xs.<span class="fu">filter</span>(x =&gt; x % <span class="dv">2</span> == <span class="dv">0</span>)) <span class="kw">yield</span> x + <span class="dv">1</span></code></pre>
</div><div id="function-literals" class="slide section level2">
<h1><span class="header-section-number">14.7</span> Function Literals</h1>
<p>In some cases, you’d like to avoid to repeat the parameter name of a literal function:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> inc: Int =&gt; Int = x =&gt; x + <span class="dv">1</span></code></pre>
<p>You can use an underscore as a placeholder for the function parameter:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> inc: Int =&gt; Int = _ + <span class="dv">1</span></code></pre>
<p>If the function takes several parameters, you can use as many underscores as parameters:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> sum = <span class="fu">fold</span>(<span class="dv">0</span>, _ + _)
<span class="kw">def</span> product = <span class="fu">fold</span>(<span class="dv">1</span>, _ * _)</code></pre>
</div><div id="currying-and-partial-application" class="slide section level2">
<h1><span class="header-section-number">14.8</span> Currying and Partial Application</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">add</span>(a: Int, b: Int) = a + b

<span class="fu">add</span>(<span class="dv">3</span>, <span class="dv">4</span>) <span class="co">// 7</span></code></pre>
<p>An equivalent computation could be the following:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">add</span>(a: Int) = (b: Int) =&gt; a + b

<span class="fu">add</span>(<span class="dv">3</span>)(<span class="dv">4</span>) <span class="co">// 7</span></code></pre>
<p>The first version takes two numbers as parameters and returns a number</p>
<p>The second version takes one number as parameter and returns a function that takes the second number and returns their sum</p>
<p>We say that the second version is a <strong>curried</strong> function</p>
</div><div id="currying-and-partial-application-2" class="slide section level2">
<h1><span class="header-section-number">14.9</span> Currying and Partial Application (2)</h1>
<p>Curried functions can be partially applied:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="kw">val</span> inc = <span class="fu">add</span>(<span class="dv">1</span>)
inc: Int =&gt; Int = &lt;function1&gt;

scala&gt; <span class="fu">inc</span>(<span class="dv">5</span>)
res0: Int = <span class="dv">6</span></code></pre>
<p>Alternatively, you can write the curried version using several <strong>parameters lists</strong>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">add</span>(a: Int)(b: Int) = a + b</code></pre>
</div><div id="tuples" class="slide section level2">
<h1><span class="header-section-number">14.10</span> Tuples</h1>
<p>Classes can combine several values together</p>
<p>But sometimes you just want to aggregate values without defining additional methods</p>
<p>In such cases, defining an extra class would be cumbersome, you can use <strong>tuples</strong> instead:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">euclideanDiv</span>(dividend: Int, divisor: Int): (Int, Int) = {
  <span class="kw">val</span> quotient = dividend / divisor
  <span class="kw">val</span> remainder = dividend % divisor
  (quotient, remainder)
}</code></pre>
</div><div id="tuples-2" class="slide section level2">
<h1><span class="header-section-number">14.11</span> Tuples (2)</h1>
<ul>
<li>The type <code>(T1, …, Tn)</code> is a tuple type of <code>n</code> elements which i<sup>th</sup> element has type <code>Ti</code></li>
<li>The value <code>(t1, …, tn)</code> is a tuple value of <code>n</code> elements</li>
</ul>
</div><div id="tuples-3" class="slide section level2">
<h1><span class="header-section-number">14.12</span> Tuples (3)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> qr = <span class="fu">euclideanDiv</span>(<span class="dv">42</span>, <span class="dv">10</span>)
<span class="fu">println</span>(qr.<span class="fu">_1</span>)
<span class="fu">println</span>(qr.<span class="fu">_2</span>)</code></pre>
<ul>
<li>Get the i<sup>th</sup> element of a tuple with the member <code>_i</code></li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> (q, r) = <span class="fu">euclideanDiv</span>(<span class="dv">42</span>, <span class="dv">10</span>)</code></pre>
<ul>
<li>Or use a <strong>tuple pattern</strong> to <em>deconstruct</em> a tuple</li>
</ul>
</div><div id="named-parameters" class="slide section level2">
<h1><span class="header-section-number">14.13</span> Named Parameters</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">Range</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">2</span>)</code></pre>
<p>It is difficult to figure out what the above program does: what is the meaning of these numbers?</p>
<p>Using <strong>named parameters</strong> can improve readability:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">Range</span>(start = <span class="dv">1</span>, end = <span class="dv">10</span>, step = <span class="dv">2</span>)</code></pre>
</div><div id="default-arguments" class="slide section level2">
<h1><span class="header-section-number">14.14</span> Default Arguments</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">square</span>(size: Int = <span class="dv">50</span>) = Rectangle(size, size)

<span class="kw">val</span> defaultSquare = <span class="fu">square</span>()
<span class="kw">val</span> customSquare = <span class="fu">square</span>(<span class="dv">100</span>)</code></pre>
</div><div id="repeated-parameters" class="slide section level2">
<h1><span class="header-section-number">14.15</span> Repeated Parameters</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">stack</span>(images: Image*): Image =
  images.<span class="fu">foldLeft</span>(emptyImage)((image, result) =&gt; image on result)

<span class="fu">stack</span>(<span class="fu">Circle</span>(<span class="dv">50</span>))
<span class="fu">stack</span>(<span class="fu">Circle</span>(<span class="dv">50</span>), Rectangle(<span class="dv">50</span>, <span class="dv">50</span>))</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> images = Seq(<span class="fu">Circle</span>(<span class="dv">50</span>), <span class="fu">Circle</span>(<span class="dv">60</span>))
<span class="fu">stack</span>(images: _*)</code></pre>
</div>
<div id="imperative-programming" class="titleslide slide section level1"><h1><span class="header-section-number">15</span> Imperative Programming</h1></div><div id="motivating-problem-random-number-generator" class="slide section level2">
<h1><span class="header-section-number">15.1</span> Motivating Problem: Random Number Generator</h1>
<p>Try to implement the following random number generator:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> next: Int = ???</code></pre>
<blockquote>
<p>Hint: a simple way to generate a sequence of pseudorandom values is to use the following recurrence relation:</p>
<p>x<sub>n+1</sub> = 22695477 x<sub>n</sub> + 1</p>
</blockquote>
<p>Example of use:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">println</span>(next)
<span class="fu">println</span>(next)</code></pre>
<ul class="incremental">
<li>The <code>next</code> method is impossible to implement!</li>
</ul>
</div><div id="motivating-problem-random-number-generator-1" class="slide section level2">
<h1><span class="header-section-number">15.2</span> Motivating Problem: Random Number Generator</h1>
<p>By changing the <code>next</code> signature, a possible implementation would be the following:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">next</span>(x: Int) = <span class="dv">22695477</span> * x + <span class="dv">1</span></code></pre>
<p>But users would be required to <em>remember</em> each value to get the next one:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x1 = <span class="fu">next</span>(<span class="dv">1</span>)
<span class="fu">println</span>(x1)
<span class="kw">val</span> x2 = <span class="fu">next</span>(x1)
<span class="fu">println</span>(x2)</code></pre>
</div><div id="assignment" class="slide section level2">
<h1><span class="header-section-number">15.3</span> Assignment</h1>
<p>A <code>var</code> definition associates a value with a name, like <code>val</code> does, but you can <strong>assign</strong> later a new value to this name:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">var</span> x = <span class="dv">10</span>
<span class="fu">println</span>(x) <span class="co">// “10”</span>
x = x + <span class="dv">10</span>
<span class="fu">println</span>(x) <span class="co">// “20”</span></code></pre>
</div><div id="imperative-loops" class="slide section level2">
<h1><span class="header-section-number">15.4</span> Imperative Loops</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">fact</span>(n: Int) = {
  <span class="kw">var</span> result = <span class="dv">1</span>
  <span class="kw">var</span> i = <span class="dv">2</span>
  <span class="kw">while</span> (i &lt;= n) {
    result = result * i
    i = i + <span class="dv">1</span>
  }
  result
}</code></pre>
</div><div id="stateful-computations" class="slide section level2">
<h1><span class="header-section-number">15.5</span> Stateful Computations</h1>
<p><code>next</code> can be implemented as follows using a <code>var</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">var</span> x = <span class="dv">1</span>
<span class="kw">def</span> <span class="fu">next</span>() = {
  x = <span class="dv">22695477</span> * x + <span class="dv">1</span>
  x
}</code></pre>
<ul>
<li>The <code>x</code> var contains the random number generator’s <strong>state</strong></li>
</ul>
</div><div id="stateful-classes" class="slide section level2">
<h1><span class="header-section-number">15.6</span> Stateful Classes</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> RNG {
  <span class="kw">private</span> <span class="kw">var</span> x = <span class="dv">1</span>
  <span class="kw">def</span> <span class="fu">next</span>() = {
    x = <span class="dv">22695477</span> * x + <span class="dv">1</span>
    x
  }
}</code></pre>
<ul>
<li>This code is a <strong>class definition</strong> which introduces :
<ul>
<li>the <code>RNG</code> type</li>
<li>the <code>RNG</code> constructor</li>
</ul></li>
</ul>
</div><div id="stateful-classes-1" class="slide section level2">
<h1><span class="header-section-number">15.7</span> Stateful Classes</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> RNG {
  <span class="kw">private</span> <span class="kw">var</span> x = <span class="dv">1</span>
  <span class="kw">def</span> <span class="fu">next</span>() = {
    x = <span class="dv">22695477</span> * x + <span class="dv">1</span>
    x
  }
}</code></pre>
<ul>
<li>The <code>RNG</code> type has two members:
<ul>
<li><code>x</code>, which is <strong>private</strong> (not reachable from the outside)</li>
<li><code>next</code></li>
</ul></li>
<li>The <code>RNG</code> class <strong>encapsulates</strong> its state</li>
</ul>
</div><div id="benefits-of-assignment" class="slide section level2">
<h1><span class="header-section-number">15.8</span> Benefits of Assignment</h1>
<ul>
<li><p><strong>Stateful objects</strong> help keeping code modular</p>
<ul>
<li>The stateful version of <code>RNG</code> does not require users to explicitly manipulate objects state (by passing an additional parameter)</li>
</ul></li>
</ul>
</div><div id="identity-and-state" class="slide section level2">
<h1><span class="header-section-number">15.9</span> Identity and State</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> rng1 = <span class="kw">new</span> RNG
<span class="kw">val</span> rng2 = <span class="kw">new</span> RNG</code></pre>
<p>Are <code>rng1</code> and <code>rng2</code> the same objects? At first glance they seem to be the same…</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">println</span>(rng1.<span class="fu">next</span>()) <span class="co">// “22695478”</span>
<span class="fu">println</span>(rng1.<span class="fu">next</span>()) <span class="co">// “-2138921681”</span>
<span class="fu">println</span>(rng2.<span class="fu">next</span>()) <span class="co">// “22695478”</span></code></pre>
<p><code>rng1</code> and <code>rng2</code> have distinct <strong>effects</strong>, they are not equals in a sense that we can not substitute one by the other</p>
<p>The introduction of assignment leads to the loss of <strong>referential transparency</strong> and makes reasonning about programs drastically more difficult</p>
</div><div id="classes-vs-case-classes-identity" class="slide section level2">
<h1><span class="header-section-number">15.10</span> Classes vs Case Classes: Identity</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> rng1 = <span class="kw">new</span> RNG
<span class="kw">val</span> rng2 = <span class="kw">new</span> RNG
rng1 == rng2</code></pre>
<ul class="incremental">
<li><code>false</code></li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> barbell1 = <span class="fu">Barbell</span>(<span class="dv">20</span>, <span class="dv">150</span>)
<span class="kw">val</span> barbell2 = <span class="fu">Barbell</span>(<span class="dv">20</span>, <span class="dv">150</span>)
barbell1 == barbell2</code></pre>
<ul class="incremental">
<li><code>true</code></li>
</ul>
</div><div id="stateful-objects-aliasing-and-copying" class="slide section level2">
<h1><span class="header-section-number">15.11</span> Stateful Objects, Aliasing and Copying</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> rng1 = <span class="kw">new</span> RNG
<span class="kw">val</span> rng2 = rng1</code></pre>
<p>Giving two different names to the <em>same</em> object can be confusing: applying a method on <code>rng1</code> will have an effect on <code>rng2</code>!</p>
<p>Stateful objects force you to distinguish between the intents of <strong>aliasing</strong> and <strong>copying</strong></p>
<p>This problem does not exist with <strong>immutable objects</strong></p>
</div><div id="classes-vs-case-classes-aliasing" class="slide section level2">
<h1><span class="header-section-number">15.12</span> Classes vs Case Classes: Aliasing</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> rng1 = <span class="kw">new</span> RNG
<span class="kw">val</span> rng2 = rng1</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> barbell1 = <span class="fu">Barbell</span>(<span class="dv">20</span>, <span class="dv">150</span>)
<span class="kw">val</span> barbell2 = barbell1</code></pre>
<ul>
<li>Immutable objects (ie. defined by case classes) can be freely aliased (it is actually a <strong>good practice</strong> to reduce the memory consumption)</li>
</ul>
</div><div id="pure-functions-and-side-effects" class="slide section level2">
<h1><span class="header-section-number">15.13</span> Pure Functions and Side-Effects</h1>
<p>Without assignment, the following declaration has only one possible implementation:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> mystery[A](a: A): A</code></pre>
<ul class="incremental">
<li><p>The identity function:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> mystery[A](a: A): A = a</code></pre></li>
<li><p>But with assignment, the following becomes possible:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> mystery[A](a: A): A = {
  <span class="fu">destroyTheWorld</span>()
  a
}</code></pre></li>
<li><p>Without assignment the type signature of a computation tells a lot about its behavior</p></li>
</ul>
</div><div id="immutability-when-possible" class="slide section level2">
<h1><span class="header-section-number">15.14</span> Immutability When Possible</h1>
<blockquote>
<p>In addition to raising complications about computational models, programs written in imperative style are susceptible to bugs that cannot occur in functional programs.</p>
</blockquote>
<p>Harold Abelson <em>et. al.</em> <em>Structure and Interpretation of Computer Programs</em>. MIT Press 1993</p>
<blockquote>
<p>Classes should be immutable unless there’s a very good reason to make them mutable….If a class cannot be made immutable, limit its mutability as much as possible.</p>
</blockquote>
<p>Joshua Bloch. <em>Effective Java</em>. Addison Wesley 2008</p>
</div><div id="safe-usage-of-vars" class="slide section level2">
<h1><span class="header-section-number">15.15</span> Safe Usage of Vars</h1>
<ul>
<li>As long as side-effects are not observable from the outside, using a var is safe:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">sum</span>(xs: Seq[Int]) = {
  <span class="kw">var</span> result = <span class="dv">0</span>
  <span class="kw">for</span> (x &lt;- xs) {
    result = result + x
  }
  result
}</code></pre>
</div>
<div id="extensibility-and-modularity" class="titleslide slide section level1"><h1><span class="header-section-number">16</span> Extensibility and Modularity</h1></div><div id="motivation-5" class="slide section level2">
<h1><span class="header-section-number">16.1</span> Motivation</h1>
<p>Your game of life implementation hard codes the rules of the game</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> GameOfLife {
  <span class="kw">def</span> <span class="fu">next</span>(world: World): World = ???
}</code></pre>
<ul>
<li>How to abstract over the rules in a way that we can easily plug a given set of rules in a given world?</li>
</ul>
</div><div id="st-solution-method-parameter" class="slide section level2">
<h1><span class="header-section-number">16.2</span> 1st Solution: Method Parameter</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> GameOfLife {
  <span class="kw">def</span> <span class="fu">next</span>(world: World, rules: (Cell, Int) =&gt; Cell): World = ???
}</code></pre>
<ul>
<li><code>rules</code> is a function taking a cell and its alive neighbours as parameter and returning the cell at the next generation</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> life = { (cell: Cell, aliveNeighbours: Int) =&gt; 
  <span class="kw">val</span> alive =
    <span class="kw">if</span> (cell.<span class="fu">isAlive</span>) aliveNeighbours == <span class="dv">2</span> || aliveNeighbours == <span class="dv">3</span>
    <span class="kw">else</span> aliveNeighbours == <span class="dv">3</span>
  <span class="fu">Cell</span>(isAlive = alive)
}
GameOfLife.<span class="fu">next</span>(…, life)</code></pre>
</div><div id="nd-solution-class-definition" class="slide section level2">
<h1><span class="header-section-number">16.3</span> 2nd Solution: Class Definition</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> <span class="fu">GameOfLife</span>(rules: (Cell, Seq[Cell]) =&gt; Cell) {
  <span class="kw">def</span> <span class="fu">next</span>(world: World): World = ???
}</code></pre>
<ul>
<li>Given this <strong>class definition</strong>, <code>GameOfLife</code> is now also a type</li>
<li>Its constructor has one parameter of type <code>(Cell, Seq[Cell] =&gt; Cell)</code></li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> gameOfLife = <span class="kw">new</span> <span class="fu">GameOfLife</span>(life)
gameOfLife.<span class="fu">next</span>(…)</code></pre>
<ul>
<li>An object of type <code>GameOfLife</code> can be created using <code>new</code></li>
</ul>
</div><div id="rd-solution-trait-definition" class="slide section level2">
<h1><span class="header-section-number">16.4</span> 3rd Solution: Trait Definition</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> GameOfLife {
  <span class="kw">def</span> <span class="fu">rules</span>(cell: Cell, neighbours: Seq[Cell]): Cell
  <span class="kw">def</span> <span class="fu">next</span>(world: World): World = ??? <span class="co">// code calling `rules`</span>
}</code></pre>
<ul>
<li>With this <strong>trait definition</strong>, <code>GameOfLife</code> has no constructor anymore</li>
<li>It has an <strong>abstract method</strong>, <code>rules</code></li>
</ul>
</div><div id="rd-solution-trait-definition-2" class="slide section level2">
<h1><span class="header-section-number">16.5</span> 3rd Solution: Trait Definition (2)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Life <span class="kw">extends</span> GameOfLife {
  <span class="kw">def</span> <span class="fu">rules</span>(cell: Cell, neighbours: Seq[Cell]) = {
    <span class="kw">val</span> alive =
      <span class="kw">if</span> (cell.<span class="fu">isAlive</span>) aliveNeighbours == <span class="dv">2</span> || aliveNeighbours == <span class="dv">3</span>
      <span class="kw">else</span> aliveNeighbours == <span class="dv">3</span>
    <span class="fu">Cell</span>(isAlive = alive)
  }
}</code></pre>
<ul>
<li>The <code>Life</code> object <strong>implements</strong> the <code>GameOfLife</code> trait</li>
<li>The <code>next</code> method is <strong>inherited</strong> from the trait</li>
<li>Unlike “sealed” trait, a simple trait can have an unlimited number of implementations</li>
</ul>
</div><div id="dynamic-method-dispatch" class="slide section level2">
<h1><span class="header-section-number">16.6</span> Dynamic Method Dispatch</h1>
<p>Consider the following program:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">run</span>(game: GameOfLife, world: World) = game.<span class="fu">next</span>(world)</code></pre>
<ul>
<li>At runtime, the implementation of the concrete type of <code>game</code> (<code>Life</code> or another one) is called</li>
<li>This process is named <strong>dynamic method dispatch</strong></li>
</ul>
</div><div id="abstract-members-encapsulation-and-modularity" class="slide section level2">
<h1><span class="header-section-number">16.7</span> Abstract Members, Encapsulation and Modularity</h1>
<ul>
<li><p>Abstract members achieve <strong>encapsulation</strong></p></li>
<li><p>Encapsulation allows the construction of <strong>abstraction layers</strong></p></li>
<li><p>It is a key principle to achieve <strong>modularity</strong>: the underlying implementation can change without affecting users</p></li>
</ul>
</div><div id="specialization" class="slide section level2">
<h1><span class="header-section-number">16.8</span> Specialization</h1>
<p><code>GameOfLife</code> is more <strong>general</strong> than <code>Life</code></p>
<p>You could also say that <code>Life</code> is more <strong>specialized</strong> than <code>GameOfLife</code></p>
<p>When specializing a type, you can:</p>
<ul>
<li>Implement abstract members</li>
<li>Add new members</li>
<li>Redefine non-abstract members</li>
</ul>
<p>A subclass <strong>conforms</strong> to its superclass, so it can be used everywhere the superclass is needed</p>
</div><div id="adding-a-member-to-a-base-class" class="slide section level2">
<h1><span class="header-section-number">16.9</span> Adding a Member to a Base Class</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> SemiGroup {
  <span class="kw">def</span> <span class="fu">append</span>(a: Int, b: Int) = a + b
}

<span class="kw">trait</span> Monoid <span class="kw">extends</span> SemiGroup {
  <span class="kw">def</span> zero = <span class="dv">0</span>
}

<span class="kw">trait</span> Group <span class="kw">extends</span> Monoid {
  <span class="kw">def</span> <span class="fu">inverse</span>(a: Int) = -a
}</code></pre>
</div><div id="redefining-a-member-of-a-base-class" class="slide section level2">
<h1><span class="header-section-number">16.10</span> Redefining a Member of a Base Class</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> LoggingSemiGroup <span class="kw">extends</span> SemiGroup {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">append</span>(a: Int, b: Int) = {
    <span class="fu">println</span>(s<span class="st">&quot;Calling append($a, $b)&quot;</span>)
    <span class="kw">super</span>.<span class="fu">append</span>(a, b)
  }
}</code></pre>
<ul>
<li>Redefine a member using <code>override</code></li>
<li>You can still refer to the base implementation using <code>super</code></li>
</ul>
</div><div id="members-visibility" class="slide section level2">
<h1><span class="header-section-number">16.11</span> Members Visibility</h1>
<p>You can control the visibility of the members of a class:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Foo {
  <span class="kw">private</span> <span class="kw">def</span> foo = <span class="dv">42</span>
  <span class="kw">protected</span> <span class="kw">def</span> bar: Int
}</code></pre>
<ul>
<li><code>private</code> members are not visible outside of the class definition</li>
<li><code>protected</code> members are not visible outside of the class definition except for subclasses</li>
</ul>
</div><div id="closing-a-class-hierarchy" class="slide section level2">
<h1><span class="header-section-number">16.12</span> Closing a Class Hierarchy</h1>
<p>You can forbid the specialization of a class or of its members:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Foo {
  <span class="kw">final</span> <span class="kw">def</span> foo = <span class="dv">42</span>
}

<span class="kw">final</span> <span class="kw">class</span> Bar <span class="kw">extends</span> Foo</code></pre>
<ul>
<li><code>final</code> members can not be overriden</li>
<li><code>final</code> classes can not be extended</li>
</ul>
</div><div id="overloading" class="slide section level2">
<h1><span class="header-section-number">16.13</span> Overloading</h1>
<p>Several members with the same name can coexist, as long their type signature is different:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">add</span>(that: Complex): Complex = …
<span class="kw">def</span> <span class="fu">add</span>(real: Double): Complex = <span class="fu">add</span>(<span class="kw">new</span> <span class="fu">Complex</span>(real, <span class="dv">0</span>)</code></pre>
</div><div id="traits-classes-objects-abstract-members-and-parameters" class="slide section level2">
<h1><span class="header-section-number">16.14</span> Traits, Classes, Objects, Abstract Members and Parameters</h1>
<ul>
<li>Traits, classes and objects are different “flavours” of type definition</li>
<li>Objects corresponds to the special case of a type with just one value</li>
<li>Traits and classes generalize several values
<ul>
<li>Traits can have abstract members</li>
<li>Classes can have constructor parameters</li>
</ul></li>
</ul>
</div><div id="components" class="slide section level2">
<h1><span class="header-section-number">16.15</span> Components</h1>
<p>You saw how to implement a set of features in a single component using classes</p>
<p>Is it possible to build a larger system by combining small components together?</p>
<p>For instance, given the following class definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Adding {
  <span class="kw">def</span> <span class="fu">add</span>(a: Int, b: Int) = a + b
}</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Multiplying {
  <span class="kw">def</span> <span class="fu">mul</span>(a: Int, b: Int) = a * b
}</code></pre>
<p>How to build calculator from these two components?</p>
</div><div id="traits" class="slide section level2">
<h1><span class="header-section-number">16.16</span> Traits</h1>
<p>Traits can encapsulate members and can be mixed together</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Adding {
  <span class="kw">def</span> <span class="fu">add</span>(a: Int, b: Int) = a + b
}

<span class="kw">trait</span> Multiplying {
  <span class="kw">def</span> <span class="fu">mul</span>(a: Int, b: Int) = a * b
}

<span class="kw">trait</span> Calculator <span class="kw">extends</span> Adding <span class="kw">with</span> Multiplying</code></pre>
<ul class="incremental">
<li>Traits can be mixed in other traits or classes using <code>extends</code> and <code>with</code></li>
</ul>
</div><div id="traits-and-dynamic-dispatch" class="slide section level2">
<h1><span class="header-section-number">16.17</span> Traits and Dynamic Dispatch</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Simple {
  <span class="kw">def</span> value = <span class="dv">7</span>
}

<span class="kw">trait</span> Double <span class="kw">extends</span> Simple {
  <span class="kw">override</span> <span class="kw">def</span> value = <span class="kw">super</span>.<span class="fu">value</span> * <span class="dv">2</span>
}

<span class="kw">trait</span> Triple <span class="kw">extends</span> Simple {
  <span class="kw">override</span> <span class="kw">def</span> value = <span class="kw">super</span>.<span class="fu">value</span> * <span class="dv">3</span>
}</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> mixin = <span class="kw">new</span> Simple <span class="kw">with</span> Double <span class="kw">with</span> Triple
<span class="fu">println</span>(mixin.<span class="fu">value</span>) <span class="co">// What is printed?</span></code></pre>
<p>Which implementation of the <code>value</code> member is called?</p>
</div><div id="traits-and-dynamic-dispatch-2" class="slide section level2">
<h1><span class="header-section-number">16.18</span> Traits and Dynamic Dispatch (2)</h1>
<div class="figure">
<img src="Traits.png" alt="Traits Linearization" /><p class="caption">Traits Linearization</p>
</div>
</div>
<div id="type-polymorphism" class="titleslide slide section level1"><h1><span class="header-section-number">17</span> Type Polymorphism</h1></div><div id="type-polymorphism-1" class="slide section level2">
<h1><span class="header-section-number">17.1</span> Type Polymorphism</h1>
<p>Until now, you saw only how to abstract over values</p>
<p>It is also possible to abstract over <strong>types</strong></p>
</div><div id="exercise-22" class="slide section level2">
<h1><span class="header-section-number">17.2</span> Exercise</h1>
<!-- FIXME Use `identity(n: Int): Int`, `identity(b: Boolean): Boolean` as an example? -->

<ul>
<li><p>Add a method <code>forAll(p: Int =&gt; Boolean): Boolean</code> to <code>IntList</code>, that tests if the predicate <code>p</code> holds for all the elements of the list</p></li>
<li><p>Then add a method <code>hasEvenSize: Boolean</code> that tests if the list has an even size</p></li>
<li><p>Generalize <code>forAll</code> and <code>hasEvenSize</code> by adding a method <code>foldBool(z: Boolean, op: (Int, Boolean) =&gt; Boolean): Boolean</code></p></li>
</ul>
<ul class="incremental">
<li>Note that the implementations of <code>fold</code> and <code>foldBool</code> are <strong>exactly the same</strong>.</li>
</ul>
<ul class="incremental">
<li>Is it possible to write only one <code>fold</code> function that would work with both <code>Int</code> and <code>Boolean</code>?</li>
</ul>
</div><div id="polymorphic-functions" class="slide section level2">
<h1><span class="header-section-number">17.3</span> Polymorphic Functions</h1>
<p>Look at the type signatures of <code>fold</code> and <code>foldBool</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">(Int,     (Int, Int)     =&gt; Int)     =&gt; Int
(Boolean, (Int, Boolean) =&gt; Boolean) =&gt; Boolean</code></pre>
<p>You could add a <code>foldString</code> with the following type signature:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">(String,  (Int, String)  =&gt; String)  =&gt; String</code></pre>
<p>It always follows this pattern:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">(A, (Int, A) =&gt; A) =&gt; A</code></pre>
</div><div id="polymorphic-functions-2" class="slide section level2">
<h1><span class="header-section-number">17.4</span> Polymorphic Functions (2)</h1>
<p>Functions can have <strong>type parameters</strong>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> fold[A](z: A, op: (Int, A) =&gt; A): A</code></pre>
<ul>
<li><code>A</code> is a <strong>type parameter</strong> (<strong>universally</strong> quantified), <code>fold</code> is a <strong>polymorphic function</strong></li>
</ul>
<p>You can then call <code>fold</code> as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> sum = fold[Int](<span class="dv">0</span>, (n, s) =&gt; s + n)
<span class="kw">def</span> <span class="fu">forAll</span>(p: Int =&gt; Boolean) = fold[Boolean](<span class="kw">true</span>, (n, b) =&gt; b &amp;&amp; <span class="fu">p</span>(n))</code></pre>
<ul class="incremental">
<li><p>Note that if you use the following signature you can help the type inference mechanism and omit the applied type in most cases:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> fold[A](z: A)(op: (Int, A) =&gt; A): A</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> sum = <span class="fu">fold</span>(<span class="dv">0</span>)((n, s) =&gt; s + n)</code></pre></li>
</ul>
</div><div id="exercise-23" class="slide section level2">
<h1><span class="header-section-number">17.5</span> Exercise</h1>
<ul>
<li>Make <code>fold</code> polymorphic</li>
</ul>
</div><div id="exercise-24" class="slide section level2">
<h1><span class="header-section-number">17.6</span> Exercise</h1>
<ul>
<li>Implement an abstract data type representing a list of <code>String</code> elements:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> StringList {
  <span class="kw">def</span> <span class="fu">add</span>(str: String): StringList
  <span class="kw">def</span> <span class="fu">concat</span>(ss: StringList): StringList
}</code></pre>
<ul class="incremental">
<li>Note the strong similarities with <code>IntList</code></li>
<li>You want to abstract over the type of the elements of the list</li>
</ul>
</div><div id="type-constructors" class="slide section level2">
<h1><span class="header-section-number">17.7</span> Type Constructors</h1>
<p>Types can have type parameters:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> List[A] {
  <span class="kw">def</span> <span class="fu">add</span>(element: A): List[A]
  <span class="kw">def</span> <span class="fu">concat</span>(as: List[A]): List[A]
}</code></pre>
<ul class="incremental">
<li><code>List</code> is a <strong>type constructor</strong>: it takes a type as parameter and yields another type
<ul class="incremental">
<li>E.g. <code>List[Int]</code>, <code>List[String]</code>, etc.</li>
</ul></li>
</ul>
</div><div id="exercise-25" class="slide section level2">
<h1><span class="header-section-number">17.8</span> Exercise</h1>
<ul>
<li>Write a polymorphic <code>List[A]</code> data type:</li>
</ul>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> List[A] {
  <span class="kw">def</span> <span class="fu">add</span>(element: A): List[A]
  <span class="kw">def</span> <span class="fu">concat</span>(as: List[A]): List[A]
  <span class="kw">def</span> fold[B](z: B)(op: (A, B) =&gt; B): B
}</code></pre>
</div><div id="type-quantification" class="slide section level2">
<h1><span class="header-section-number">17.9</span> Type Quantification</h1>
<p>Subtyping and universal types are two different generalization mechanisms. Can you mix them together?</p>
<p>Consider the following class hierarchy:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Animal {
  <span class="kw">def</span> fitness: Int
}

<span class="kw">trait</span> Reptile <span class="kw">extends</span> Animal

<span class="kw">trait</span> Mammal <span class="kw">extends</span> Animal

<span class="kw">trait</span> Zebra <span class="kw">extends</span> Mammal {
  <span class="kw">def</span> zebraCount: Int
}

<span class="kw">trait</span> Giraffe <span class="kw">extends</span> Mammal</code></pre>
<p>You want to write a function <code>selection</code>, that takes two animals as parameters and returns the one with the highest <code>fitness</code> value. What will its type signature be?</p>
</div><div id="type-quantification-2" class="slide section level2">
<h1><span class="header-section-number">17.10</span> Type Quantification (2)</h1>
<p>A possible solution using subtyping is the following:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">selection</span>(a1: Animal, a2: Animal) =
  <span class="kw">if</span> (a1.<span class="fu">fitness</span> &gt; a2.<span class="fu">fitness</span>) a1 <span class="kw">else</span> a2</code></pre>
<p>What is the problem with this solution?</p>
<ul class="incremental">
<li>The return type is <code>Animal</code>: call it with two <code>Zebra</code>s and you get only an <code>Animal</code>
<ul class="incremental">
<li>You loose the ability to access further its <code>zebraCount</code> member</li>
</ul></li>
</ul>
</div><div id="type-quantification-3" class="slide section level2">
<h1><span class="header-section-number">17.11</span> Type Quantification (3)</h1>
<p>We could try to solve this issue using a universal type:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> selection[A](a1: A, a2: A): A =
  <span class="kw">if</span> (a1.<span class="fu">fitness</span> &gt; a2.<span class="fu">fitness</span>) a1 <span class="kw">else</span> a2</code></pre>
<p>But this solution does not compile: we can not access the <code>fitness</code> member of <code>a1</code> and <code>a2</code> because <code>A</code> is not constrained to be a subtype of <code>Animal</code></p>
</div><div id="upper-and-lower-bounds" class="slide section level2">
<h1><span class="header-section-number">17.12</span> Upper and Lower Bounds</h1>
<p>We can write a better solution using a <strong>bounded quantification</strong>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> selection[A &lt;: Animal](a1: A, a2: A): A =
   <span class="kw">if</span> (a1.<span class="fu">fitness</span> &gt; a2.<span class="fu">fitness</span>) a1 <span class="kw">else</span> a2</code></pre>
<ul>
<li><code>A &lt;: Animal</code> means “for all type <code>A</code> that is a subtype of <code>Animal</code>”, and we say that <code>Animal</code> is the <strong>upper bound</strong> of <code>A</code></li>
</ul>
<p>Similarly, you can constraint a type parameter <code>A</code> to have a <strong>lower bound</strong> <code>B</code>:</p>
<ul>
<li><code>A &gt;: B</code></li>
</ul>
</div><div id="variance" class="slide section level2">
<h1><span class="header-section-number">17.13</span> Variance</h1>
<p>Consider the following type modeling a zoo run containing an animal:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Run[A] {
  <span class="kw">def</span> get: A <span class="co">// Get the animal that lives in this run</span>
}</code></pre>
<p>Mammal well being is a serious subject, the following function checks that a given run has the appropriate size regarding to the animal that lives in (provided you have methods in <code>Run[A]</code> and <code>Mammal</code> that give you their size):</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">isLargeEnough</span>(run: Run[Mammal]): Boolean = …</code></pre>
<p>What happens if you pass it a <code>Run[Zebra]</code> as parameter?</p>
</div><div id="variance-2" class="slide section level2">
<h1><span class="header-section-number">17.14</span> Variance (2)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="fu">isLargeEnough</span>(zebraRun)
&lt;console&gt;:<span class="dv">14</span>: error: <span class="kw">type</span> mismatch;
 found   : Run[Zebra]
 required: Run[Mammal]</code></pre>
<p>A <code>Run[Zebra]</code> is not a subtype of <code>Run[Mammal]</code>, in fact they are just two different types without any subtyping relation. Could it be otherwise? Should it be otherwise?</p>
<ul class="incremental">
<li>Intuitively, a run with a zebra is just a special case of a run with a mammal</li>
<li><code>isLargeEnough</code> can only use the <code>get</code> member of its <code>Run[Mammal]</code> parameter, and expects to get a <code>Mammal</code> value</li>
<li>A <code>Run[Zebra]</code> value has a <code>get</code> member that returns a <code>Zebra</code>, which is a <code>Mammal</code></li>
<li>It seems that <code>Run[Zebra]</code> should be a subtype of <code>Run[Mammal]</code></li>
</ul>
</div><div id="covariance" class="slide section level2">
<h1><span class="header-section-number">17.15</span> Covariance</h1>
<p>More generally, <code>Run[A] &lt;: Run[B]</code> if <code>A &lt;: B</code></p>
<p>We say that <code>A</code> is <strong>covariant</strong> in <code>Run[A]</code> and we can tell it to the compiler as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Run[+A] {
  <span class="kw">def</span> get: A
}</code></pre>
<p>Now the compiler accepts that you pass a <code>Run[Zebra]</code> where a <code>Run[Mammal]</code> is expected</p>
</div><div id="variance-3" class="slide section level2">
<h1><span class="header-section-number">17.16</span> Variance (3)</h1>
<p>Consider the following type modeling a veterinary able to treat animals:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Vet[A] {
  <span class="kw">def</span> <span class="fu">treat</span>(a: A)
}</code></pre>
<p>And the following function treating all the mammals of the zoo using a veterinary passed as parameter:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">treatMammals</span>(vet: Vet[Mammal]) { … }</code></pre>
<p>What happens if you pass it a <code>Vet[Animal]</code> as parameter?</p>
</div><div id="variance-4" class="slide section level2">
<h1><span class="header-section-number">17.17</span> Variance (4)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala">scala&gt; <span class="fu">treatMammals</span>(animalVet)
&lt;console&gt;:<span class="dv">14</span>: error: <span class="kw">type</span> mismatch;
 found   : Vet[Animal]
 required: Vet[Mammal]</code></pre>
<p>A <code>Vet[Animal]</code> is not a subtype of <code>Vet[Mammal]</code>, they are just two different types. Should it be otherwise?</p>
<ul class="incremental">
<li>Intuitively, a veterinary that can treat animals can treat mammals, because a mammal is just a special case of an animal</li>
<li><code>treatMammals</code> can only use the <code>treat</code> member of its <code>Vet[Mammal]</code> parameter, and can pass it any <code>Mammal</code> value</li>
<li>A <code>Vet[Animal]</code> has a <code>treat</code> member that takes an <code>Animal</code> as parameter, so it can take a <code>Mammal</code> as well, because <code>Mammal</code> is a subtype of <code>Animal</code></li>
<li>It seems that <code>Vet[Animal]</code> should be a subtype of <code>Vet[Mammal]</code></li>
</ul>
</div><div id="contravariance" class="slide section level2">
<h1><span class="header-section-number">17.18</span> Contravariance</h1>
<p>More generally, <code>Vet[A] &lt;: Vet[B]</code> if <code>A &gt;: B</code></p>
<p>We say that <code>A</code> is <strong>contravariant</strong> in <code>Run[A]</code> and we can tell it to the compiler as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Vet[-A] {
  <span class="kw">def</span> <span class="fu">treat</span>(a: A)
}</code></pre>
<p>Now the compiler accepts that you pass a <code>Vet[Animal]</code> where a <code>Vet[Mammal]</code> is expected</p>
</div><div id="variance-5" class="slide section level2">
<h1><span class="header-section-number">17.19</span> Variance (5)</h1>
<p>For a type constructor <code>F[X]</code>, variance annotations allow you to define the subtyping relation of the types <code>F[A]</code> and <code>F[B]</code> according to the subtyping relation of the types <code>A</code> and <code>B</code></p>
<p>By default, type parameters are <strong>invariant</strong></p>
</div><div id="exercise-26" class="slide section level2">
<h1><span class="header-section-number">17.20</span> Exercise</h1>
<ul>
<li>Make the <code>List</code> class covariant</li>
</ul>
</div>
<div id="type-classes-and-implicit-parameters" class="titleslide slide section level1"><h1><span class="header-section-number">18</span> Type Classes and Implicit Parameters</h1></div><div id="motivating-problem" class="slide section level2">
<h1><span class="header-section-number">18.1</span> Motivating Problem</h1>
<p>Remember the <code>sum</code> method of <code>IntList</code>?</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">sumInts</span>(xs: List[Int]): Int = xs.<span class="fu">fold</span>(<span class="dv">0</span>)(_ + _)</code></pre>
<p>What if we want to compute the sum of a list of complex numbers?</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">sumComplexes</span>(zs: List[Complex]): Complex =
  zs.<span class="fu">fold</span>(<span class="kw">new</span> <span class="fu">Complex</span>(<span class="dv">0</span>, <span class="dv">0</span>))(_ add _)</code></pre>
<ul>
<li>Can we abstract over the similarities of <code>sumInts</code> and <code>sumComplexes</code>?</li>
</ul>
</div><div id="motivating-problem-2" class="slide section level2">
<h1><span class="header-section-number">18.2</span> Motivating Problem (2)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Sumable[A &lt;: Sumable[A]] {
  <span class="kw">def</span> + (that: A): A
}

<span class="kw">def</span> sum[A &lt;: Sumable[A]](as: List[A], zero: A): A =
  as.<span class="fu">fold</span>(zero)(_ + _)</code></pre>
<p>We can change the implementation of <code>Complex</code> to extend <code>Sumable[Complex]</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Complex <span class="kw">extends</span> Sumable[Complex] {
  <span class="kw">def</span> + (that: Complex) = <span class="fu">add</span>(that)
  …
}</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> zs = List(<span class="kw">new</span> <span class="fu">Complex</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">new</span> <span class="fu">Complex</span>(<span class="dv">3</span>, <span class="dv">4</span>))
<span class="fu">sum</span>(zs, <span class="kw">new</span> <span class="fu">Complex</span>(<span class="dv">0</span>, <span class="dv">0</span>))</code></pre>
</div><div id="motivating-problem-3" class="slide section level2">
<h1><span class="header-section-number">18.3</span> Motivating Problem (3)</h1>
<ul>
<li><p>We can not change the implementation of <code>Int</code> to make it extend <code>Sumable[Int]</code></p></li>
<li><p>Anyway, this <code>Sumable</code> trait captures only a part of the problem: we still need to manually supply the identity element corresponding to each type</p></li>
</ul>
</div><div id="almost-type-classes" class="slide section level2">
<h1><span class="header-section-number">18.4</span> (Almost) Type Classes</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Sumable[A] {
  <span class="kw">def</span> zero: A
  <span class="kw">def</span> <span class="fu">append</span>(a1: A, a2: A): A
}</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> sum[A](as: List[A], A: Sumable[A]) =
  as.<span class="fu">fold</span>(A.<span class="fu">zero</span>)(A.<span class="fu">append</span>)</code></pre>
</div><div id="retroactive-extension" class="slide section level2">
<h1><span class="header-section-number">18.5</span> Retroactive Extension</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> sumableInt = <span class="kw">new</span> Sumable[Int] {
  <span class="kw">val</span> zero = <span class="dv">0</span>
  <span class="kw">def</span> <span class="fu">append</span>(a1: Int, a2: Int) = a1 + a2
}</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> xs = List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>)
<span class="fu">sum</span>(xs, sumableInt)</code></pre>
</div><div id="retroactive-extension-2" class="slide section level2">
<h1><span class="header-section-number">18.6</span> Retroactive Extension (2)</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> sumableComplex = <span class="kw">new</span> Sumable[Complex] {
  <span class="kw">val</span> zero = <span class="kw">new</span> <span class="fu">Complex</span>(<span class="dv">0</span>, <span class="dv">0</span>)
  <span class="kw">def</span> <span class="fu">append</span>(a1: Complex, a2: Complex) = a1.<span class="fu">add</span>(a2)
}</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> zs = List(<span class="kw">new</span> <span class="fu">Complex</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">new</span> <span class="fu">Complex</span>(<span class="dv">3</span>, <span class="dv">4</span>))
<span class="fu">sum</span>(zs, sumableComplex)</code></pre>
</div><div id="almost-type-classes-2" class="slide section level2">
<h1><span class="header-section-number">18.7</span> (Almost) Type Classes (2)</h1>
<ul>
<li><p>The <code>Sumable[A]</code> trait captures everything we need to make a sum of a list of <code>A</code> (the identity element and the binary operation)</p></li>
<li><p>However, we need to explicitly supply the instance corresponding to each type</p>
<ul>
<li><p>To compute a sum of <code>Int</code> we explicitly pass <code>sumableInt</code></p></li>
<li><p>To compute a sum of <code>Complex</code> we explicitly pass <code>sumableComplex</code></p></li>
</ul></li>
</ul>
</div><div id="implicit-parameters" class="slide section level2">
<h1><span class="header-section-number">18.8</span> Implicit Parameters</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> sum[A](as: List[A])(<span class="kw">implicit</span> A: Sumable[A]) =
  as.<span class="fu">fold</span>(A.<span class="fu">zero</span>)(A.<span class="fu">append</span>)</code></pre>
<p><code>sum</code> takes an <strong>implicit parameter</strong> of type <code>Sumable[A]</code></p>
<p>If you define <code>sumableInt</code> and <code>sumableComplex</code> as <strong>implicit values</strong> you can omit to supply them when calling <code>sum</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">val</span> sumableInt = …
<span class="kw">implicit</span> <span class="kw">val</span> sumableComplex = …</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sum</span>(xs)
<span class="fu">sum</span>(zs)</code></pre>
</div><div id="implicit-parameters-2" class="slide section level2">
<h1><span class="header-section-number">18.9</span> Implicit Parameters (2)</h1>
<p>If you call a method without supplying its implicit parameters, the compiler tries to resolve them in the <strong>implicit scope</strong></p>
<p>The implicit scope is basically built using (by order of priority, highest first):</p>
<ul>
<li><p>implicit values of the current lexical scope or outer scopes,</p></li>
<li><p>explicitly imported implicit values (e.g. <code>import path.to.some.Implicits._</code>),</p></li>
<li><p>the implicit values of companion objects of the implicit parameter’s type</p></li>
</ul>
</div><div id="context-bounds" class="slide section level2">
<h1><span class="header-section-number">18.10</span> Context Bounds</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> sum[A : Sumable](as: List[A]) = {
  <span class="kw">val</span> A = implicitly[Sumable[A]]
  xs.<span class="fu">fold</span>(A.<span class="fu">zero</span>)(A.<span class="fu">append</span>)
}</code></pre>
<ul>
<li><p><code>A : F</code> expands to an implicit parameter of type <code>F[A]</code></p></li>
<li><p>We say that <code>F</code> is a <strong>context bound</strong> for <code>A</code></p></li>
<li><p>You can retrieve an implicit parameter using the <code>implicitly</code> helper</p></li>
<li><p>Sometimes the context bound notation is shorter than using an implicit parameter list</p></li>
</ul>
</div>
</body>
</html>
